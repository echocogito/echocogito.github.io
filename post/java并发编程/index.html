<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Scavenger Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://echocogito.github.io//img/home-page-yinyeshasgoy.jpg">
    <meta property="twitter:image" content="https://echocogito.github.io//img/home-page-yinyeshasgoy.jpg" />
    

    
    <meta name="title" content="Java并发编程" />
    <meta property="og:title" content="Java并发编程" />
    <meta property="twitter:title" content="Java并发编程" />
    

    
    <meta name="description" content="这场残暴的欢愉,终将以残暴终结">
    <meta property="og:description" content="这场残暴的欢愉,终将以残暴终结" />
    <meta property="twitter:description" content="这场残暴的欢愉,终将以残暴终结" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="JAVA,PYTHON,GOLANG,VUE.js">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Java并发编程 | 拾荒者博客</title>

    <link rel="canonical" href="/post/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>




<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Scavenger Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/programming">programming</a>
                        </li>
                        
                        <li>
                            <a href="/categories/tech">tech</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/archive/">ARCHIVE</a></li>
                    
                        <li><a href="/notes/">NOTES</a></li>
                    
                        <li><a href="/about/">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/article-default.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/java" title="java">
                            java
                        </a>
                        
                        <a class="tag" href="/tags/juc" title="juc">
                            juc
                        </a>
                        
                    </div>
                    <h1>Java并发编程</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                Noper
                             
                            on 
                            Sunday, October 30, 2022
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h1 id="绪论">绪论</h1>
<p>Java并发编程全景图</p>
<p>
  <img src="/img/JUC/1628322115512.png" alt="1628322115512">

</p>
<h2 id="并发编程的三个核心问题分工同步互斥">并发编程的三个核心问题：分工、同步、互斥</h2>
<p>所谓分工指的是如何高效地拆解任务并分配给线程，而同步指的是线程之间如何协作，互斥则是保证同一时刻只允许一个线程访问共享资源。java SDK并发包很大部分内容都是按照这三个维度组织的，例如Fork/Join框架就是一种分工模式，CountDownLatch就是一种典型的同步方式，而可重入锁则是一种互斥手段。</p>
<h2 id="分工如何高效的拆解任务并分配给线程">分工：如何高效的拆解任务并分配给线程</h2>
<p>所谓分工，类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。</p>
<p>​    在并发编程领域，你就是项目经理，线程就是项目组成员。任务分解和分工对于项目成败非常关键，不过在并发领域里，分工更重要，它直接决定了并发程序的性能。在现实世界里，分工是很复杂的，著名数学家华罗庚曾用“烧水泡茶”的例子通俗地讲解了统筹方法（一种安排工作进程的数学方法），“烧水泡茶”这么简单的事情都这么多说道，更何况是并发编程里的工程问题呢。</p>
<p>​    既然分工很重要又很复杂，那一定有前辈努力尝试解决过，并且也一定有成果。的确，在并发编程领域这方面的成果还是很丰硕的。Java SDK并发包里的Executor、Fork/Join、Future本质上就是一种分工方法。除此之外，并发编程领域还总结了一些设计模式，基本上都是和分工方法相关的，例如生产者-消费者、Thread-Per-Message、Worker Thread模式等都是用来指导你如何分工的。</p>
<p>​    了解这部分内容，最佳的方式就是和现实世界做对比。例如生产者-消费者模式，可以类比一下餐馆里的大厨和服务员，大厨就是生产者，负责做菜，做完放到出菜口，而服务员就是消费者，把做好的菜给你端过来。不过，我们经常会发现，出菜口有时候一下子出了好几个菜，服务员是可以吧这一批菜同时端给你的。其实这就是生产者-消费者模式的一个优点，生产者一个一个地生产数据，而消费者可以批处理，这样就提高了性能。</p>
<h2 id="同步线程之间如何协作">同步：线程之间如何协作</h2>
<p>分好工之后，就是具体执行了。在项目执行过程中，任务之间是有依赖的，一个任务结束后，依赖它的后续任务任务就可以开工了，后续工作怎么知道可以开工了呢？这个就是靠沟通协作了，这是一项很重要的工作。</p>
<p>​    在并发编程领域里的同步，主要指的就是线程间的协作，本质上和现实生活中的协作没区别，不过是一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已。协作一般是和分工相关的。Java SDK并发包里的Executor、Fork/Join、Future本质上都是分工方法，但同时也能解决线程协作的问题。例如，用Future可以发起一个异步调用，当主线程通过get()方法取结果时，主线程就会等待，当异步执行的结果返回时，get()方法就自动返回了。主线程和异步线程之间的协作，Future工具类已经帮我们解决了。除此之外，Java SDK里提供的CountDownLatch、CyclicBarrier、Phaser、Exchanger也都是用来解决线程协作的问题。</p>
<p>​    不过还有很多场景，是需要你自己来处理线程之间的协作的。</p>
<p>​    工作中遇到的线程协作的问题，基本上都可以描述为这样的一个问题:当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行。例如，在生产者-消费者模型里，也有类似的描述，“当队列满时，生产者线程等待，当队列不满时，生产者线程需要被唤醒执行；当队列空时，消费者线程等待，当队列不为空时，消费者线程需要被唤醒执行。”</p>
<p>​    在Java并发编程领域，解决协作问题的核心技术是管程，上面提到的所有线程协作技术底层都是利用管程解决的。管程是一种解决并发问题的通用模型，除了能解决线程协作问题，还能解决下面我们将要介绍的互斥问题。可以这么说，管程是解决并发问题的万能钥匙。</p>
<p>​    所以说，这部分内容的学习，关键是理解管程模型，学好它就可以解决所有问题。其次，了解Java SDK并发包提供的几个线程协作的工具类的应用场景，用好它们可以妥妥地提高你的工作效率。</p>
<h2 id="互斥保证同一时刻只允许一个线程访问共享资源">互斥：保证同一时刻只允许一个线程访问共享资源</h2>
<p>分工、同步主要强调的是性能，但并发程序里还有一部分是关于正确性的，用专业术语叫“线程安全”。并发程序里，当多个线程同时访问一个共享变量时，结果时不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。而导致不确定的主要源头是可见性的问题、有序性问题和原子性问题，为了解决这三个问题，Java语言引入了内存模型，内存模型提供了一系列的规则，利用这些规则，我们可以避免可见性问题、有序性问题，但是还不足以完全解决线程安全问题。解决线程安全问题的核心方案还是互斥。</p>
<p><strong>所谓互斥，指的是同一时刻，只允许一个线程访问共享变量</strong></p>
<p>实现互斥的核心技术就是锁，Java语言里synchronized、SDK里的各种Lock都能解决互斥问题。虽说锁解决了安全性问题，但同时也带来了性能问题，那如何保证安全性的同时又尽量提高性能呢？可以分场景优化，Java SDK里提供的ReadWriteLock、StampedLock就可以优化读多写少场景下锁的性能。还可以使用无锁的数据结构，例如Java SDK里提供的原子类都是基于无锁技术实现的。</p>
<p>​    除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了Thread Local和final关键字，还有一种copy-on-write的模式。</p>
<p>​    使用锁除了要注意性能问题外，还需要注意死锁问题。</p>
<p>​    这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些CPU和缓存的知识；要理解原子性，就需要理解一些操作系统的知识；很多无锁算法的实现往往也需要理解CPU缓存。这部分内容，需要博览群书，在大脑里建立起CPU、内存、I/O执行的模拟器。这样遇到问题就能得心应手了。</p>
<h1 id="java并发编程">Java并发编程</h1>
<h2 id="一-java并发编程概述">一. Java并发编程概述</h2>
<h3 id="1--并发的三种场景">1.  并发的三种场景</h3>
<h4 id="11--为什么要做并发">1.1  为什么要做并发？</h4>
<p>我们的计算机就像是一个工厂，线程就是里面的工人，内存，CPU，IO这些是不同的资源，实际工厂里工人用资源生产不同的产品，在计算机中也一样，线程使用计算机资源完成不同的工作。</p>
<p>工厂希望生产更多更复杂的产品，就需要对个工人进行复杂的协作，计算机也一样，要发挥更大的性能，就需要线程并发协作，整个线程协作过程也和工厂一样，分为三类场景：分工，同步和互斥。</p>
<h4 id="12-并发的三种场景">1.2 并发的三种场景</h4>
<h5 id="分工">分工</h5>
<p>多线程并发编程最基本的场景就是分工，就是线程各司其职，完成不同的工作。分工也有很多种模式，比如：</p>
<ul>
<li>生产者-消费者模式，大厨做饭，我们来吃</li>
<li>MapReduce模式，把工作拆分成多份，多个线程共同完成后，再结合结果，java8中的stream和Fork/Join就是这种模式的体现</li>
<li>Thread-Pre-Message模式，服务端就是这种模式，收到消息给不同的Thread进行处理</li>
<li>&hellip;&hellip;</li>
</ul>
<h5 id="同步">同步</h5>
<p>有分工就需要同步，不同工人之间要协作，不同线程也是，一个线程执行条件往往依赖于另一个线程的执行结果</p>
<p>线程之间最基本的通信机制是管理模式与wait/notify，除此之外还有多个工具类，如：</p>
<ul>
<li>Future及其衍生的工具类FutureTask/CompletabaleFuture等，可以完成异步编程</li>
<li>CountDownLatch/CyclicBarrier/Phaser/Exchanger可以实现特定场景的协作</li>
<li>Semaphore提供了经典的PV同步原语，还可以为限流使用</li>
<li>ReentrantLock与Condition，对管程同步的扩展</li>
<li>&hellip;&hellip;</li>
</ul>
<h5 id="互斥">互斥</h5>
<p>不同工人，操作相同的共享资源，就有可能冲突，类似，多线程访问相同的共享变量，就需要做互斥处理，分工与协作强调的是性能，互斥问题强调的是正确，即线程安全问题。Java解决互斥问题提供了很多思路与工具，如：</p>
<ul>
<li>避免共享，没有共享，就没有竞态，就没有伤害，如ThreadLocal</li>
<li>没有改变，如果大家多不做改变，都是只读的，一起也没问题，如final关键字</li>
<li>Copy-On-Write，你变你的 ，我变我的，没改变一次都生成新的副本，只要不冲突就可以并行</li>
<li>CAS，写入前看一看，有没有物是人非（变量可自己读取时一样），没有再写入，否则再做一遍</li>
<li>Lock，最终手段，但也不想做的太绝，够用就行，ReadWriteLock/StampedLock，够用就行</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="2-并发问题的源头">2. 并发问题的源头</h3>
<p>并发的各种问题可归结为三大源头：</p>
<h5 id="21-缓存导致的可见性问题">2.1 缓存导致的可见性问题</h5>
<p>计算机组成原理告诉我们，CPU与内存速度不一致，为了了解这种不一致，我们加入了CPU缓存。因此，在运行时，同一份数据就出现了两份，一个在内存，一个在CPU缓存。在单核CPU，这没什么问题，只要缓存中存在变量的副本，就操作同一个副本即可。多线程修改为同一个变量，修改的结果对其他线程也可见。</p>
<p>但在CPU多核时代，就有可见性问题，如下图所示：</p>
<p>
  <img src="/img/JUC/image-20210727224944365.png" alt="image-20210727224944365">

</p>
<p>同一个变量在多个线程中可能有多个副本，线程对副本的操作对其他线程不可见。</p>
<p>例子：两个线程对共享变量多1W次的自增，期望结果时2W，但实例的结果是在1W到2W之间。</p>
<p>代码：略（后续补充）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">ThreadTest</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">int</span> count <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">;</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">add</span><span style="color:#ff79c6">(){</span>
        <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">;</span> i <span style="color:#ff79c6">&lt;</span> 10000<span style="color:#ff79c6">;</span> i<span style="color:#ff79c6">++)</span> <span style="color:#ff79c6">{</span>
            count <span style="color:#ff79c6">+=</span> 1<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>

    <span style="color:#ff79c6">}</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">main</span><span style="color:#ff79c6">(</span>String<span style="color:#ff79c6">[]</span> args<span style="color:#ff79c6">)</span> <span style="color:#8be9fd;font-style:italic">throws</span> InterruptedException <span style="color:#ff79c6">{</span>
        Thread t1 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Thread<span style="color:#ff79c6">(()-&gt;{</span>add<span style="color:#ff79c6">();});</span>
        Thread t2 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Thread<span style="color:#ff79c6">(()-&gt;{</span>add<span style="color:#ff79c6">();});</span>
        t1<span style="color:#ff79c6">.</span><span style="color:#50fa7b">start</span><span style="color:#ff79c6">();</span>
        t2<span style="color:#ff79c6">.</span><span style="color:#50fa7b">start</span><span style="color:#ff79c6">();</span>
        t1<span style="color:#ff79c6">.</span><span style="color:#50fa7b">join</span><span style="color:#ff79c6">();</span>
        t2<span style="color:#ff79c6">.</span><span style="color:#50fa7b">join</span><span style="color:#ff79c6">();</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>count<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>

<span style="color:#6272a4">//结果
</span><span style="color:#6272a4"></span>13525
</code></pre></div><p>解决办法，使用原子类，保证内存可见性</p>
<h5 id="22-线程切换带来的原子性问题">2.2 线程切换带来的原子性问题</h5>
<p>我们的计算机看起来可以同时运行多于自身核数的线程，是因为现代操作系统的分时切换机制。分时切换机制提高了CPU的使用率，也可以保证多线程可以相对公平的获取CPU，但分时机制导致一个不可避免的问题，就是线程切换。发生线程切换时，被休眠的线程会暂存现场，包括PC与栈等，等到次线程再次被唤醒，可能发现这个世界已经物是人非了，因为一条高级语言指令可能对于多条CPU指令</p>
<p>以<strong>count+=1</strong>为例，这条表达式至少对应三条CPU指令：</p>
<ul>
<li>从内存加载count变量到寄存器</li>
<li>寄存器做+1操作</li>
<li>将结果写入内存（忽略可见性问题，假设直接进内存）</li>
</ul>
<p>
  <img src="/img/JUC/image-20210727230926902.png" alt="image-20210727230926902">

</p>
<p>线程A完成读后，发生线程切换。切换到B，线程B完成了读写，在切回线程A，线程A继续执行，再次把count+1写入内存。因此，最终结果不是我们期望的count+2，还是count+1。</p>
<p>解决办法，使用原子类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">ThreadTest</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">static</span> AtomicInteger count <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> AtomicInteger<span style="color:#ff79c6">(</span>0<span style="color:#ff79c6">);</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">add</span><span style="color:#ff79c6">(){</span>
        <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">;</span> i <span style="color:#ff79c6">&lt;</span> 10000<span style="color:#ff79c6">;</span> i<span style="color:#ff79c6">++)</span> <span style="color:#ff79c6">{</span>
            count<span style="color:#ff79c6">.</span><span style="color:#50fa7b">incrementAndGet</span><span style="color:#ff79c6">();</span>
        <span style="color:#ff79c6">}</span>

    <span style="color:#ff79c6">}</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">main</span><span style="color:#ff79c6">(</span>String<span style="color:#ff79c6">[]</span> args<span style="color:#ff79c6">)</span> <span style="color:#8be9fd;font-style:italic">throws</span> InterruptedException <span style="color:#ff79c6">{</span>
        Thread t1 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Thread<span style="color:#ff79c6">(()-&gt;{</span>add<span style="color:#ff79c6">();});</span>
        Thread t2 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Thread<span style="color:#ff79c6">(()-&gt;{</span>add<span style="color:#ff79c6">();});</span>
        t1<span style="color:#ff79c6">.</span><span style="color:#50fa7b">start</span><span style="color:#ff79c6">();</span>
        t2<span style="color:#ff79c6">.</span><span style="color:#50fa7b">start</span><span style="color:#ff79c6">();</span>
        t1<span style="color:#ff79c6">.</span><span style="color:#50fa7b">join</span><span style="color:#ff79c6">();</span>
        t2<span style="color:#ff79c6">.</span><span style="color:#50fa7b">join</span><span style="color:#ff79c6">();</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>count<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>

<span style="color:#6272a4">//结果
</span><span style="color:#6272a4"></span>20000
</code></pre></div><h5 id="23-编译优化带来的有序性问题">2.3 编译优化带来的有序性问题</h5>
<p>Java为了优化性能，可能对指令进行重排，这些重排在大部分时候是无害的，但有些时候，可能导致意想不到的 BUg。由重排引起的一个金典问题是双重检验创建单例</p>
<p>如下面的单例创建代码，在getInstance方法中，我们先判断instance是否为空，为空则锁整个类，创建前再判断一次是否为空，为空再创建，锁定之后在判断，是为了避免在第一次判断后，线程中断，其他线程完成了创建。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">SingletonTest</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#50fa7b">SingletonTest</span><span style="color:#ff79c6">(){}</span>
    <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> SingletonTest instance<span style="color:#ff79c6">;</span>
    
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> SingletonTest <span style="color:#50fa7b">getInstance</span><span style="color:#ff79c6">(){</span>
        <span style="color:#ff79c6">if</span><span style="color:#ff79c6">(</span>instance <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">){</span>
            <span style="color:#8be9fd;font-style:italic">synchronized</span> <span style="color:#ff79c6">(</span>SingletonTest<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">){</span>
                <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>instance <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">){</span>
                    instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> SingletonTest<span style="color:#ff79c6">();</span>
                <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">}</span>
        <span style="color:#ff79c6">}</span>
        <span style="color:#ff79c6">return</span> instance<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>这一切看似很完美，但实际上，这种单例模式的实现还是有问题的。因为new操作被重排了，我们认为new操作应该是：</p>
<ul>
<li>分配一块内存</li>
<li>在内存上完成Singleton对象的初始化</li>
<li>把内存地址给instance</li>
</ul>
<p>实际上优化后是这样的：</p>
<ul>
<li>分配一块内存</li>
<li>将内存地址给instance</li>
<li>在内存上完成Singleton对象的初始化</li>
</ul>
<p>优化后可能出现访问单例成员出现空指针异常，我们假设有两个线程A，B，A执行getInstance到指令2时，线程切换到线程B，线程B看到getInstance已经不为空，认为可用了。但这是还没有进行对象初始化，这时使用instance，就可能出现问题</p>
<p>
  <img src="/img/JUC/image-20210728210957955.png" alt="image-20210728210957955">

</p>
<p>解决办法，使用volatile关键字，禁止指令重排</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">SingletonTest</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#50fa7b">SingletonTest</span><span style="color:#ff79c6">(){}</span>
    <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">volatile</span> SingletonTest instance<span style="color:#ff79c6">;</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> SingletonTest <span style="color:#50fa7b">getInstance</span><span style="color:#ff79c6">(){</span>
        <span style="color:#ff79c6">if</span><span style="color:#ff79c6">(</span>instance <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">){</span>
            <span style="color:#8be9fd;font-style:italic">synchronized</span> <span style="color:#ff79c6">(</span>SingletonTest<span style="color:#ff79c6">.</span><span style="color:#50fa7b">class</span><span style="color:#ff79c6">){</span>
                <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>instance <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">){</span>
                    instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> SingletonTest<span style="color:#ff79c6">();</span>
                <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">}</span>
        <span style="color:#ff79c6">}</span>
        <span style="color:#ff79c6">return</span> instance<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><h3 id="3-并发带来的问题安全性活跃性和性能">3. 并发带来的问题：安全性，活跃性和性能</h3>
<p>在《Java并发编程实战》中，我们知道Java的并发问题可以归结为三类：安全性问题，活跃性问题和性能问题</p>
<h5 id="31-安全性问题">3.1 安全性问题</h5>
<p>安全性问题本质上是正确性问题。即程序按我们期望的方式执行。但前一节，我们介绍过，并发程序因为可见性，原子性以及有序性问题有时会发生诡异的BUG，好在我们可以确定这个BUG的发生条件：</p>
<p><strong>多线程共享一个数据，且数据是可写的</strong></p>
<p>当这个条件出现时，我们就需要考虑，程序是否存在安全性问题，安全性问题可以分为两类，数据竞争与竞态条件。</p>
<p>数据竞争，就是我们一般说的，多个线程访问共享变量。</p>
<p>竞态条件，就是指程序的执行结果依赖线程的执行顺序。有竞态条件的代码一般是下面这种模式</p>
<pre><code>if(状态条件 满足 执行条件){执行操作}
</code></pre><p>当某个线程发现状态满足时，开始执行操作，但在判断满足之后，开始执行之前，条件被别的线程修改了。对于竞态条件问题，一个是基本的方法就是锁，我们把上面这种模式的代码片段，称之为状态变量的临界区，第一个进入临界区的线程就是将临界区锁定。</p>
<h5 id="32-活跃性问题">3.2 活跃性问题</h5>
<p>所谓的活跃性问题，指的就是某个操作无法执行下去，我们常见的“死锁”就是典型的活跃性问题。除了死锁，活跃性问题还有两种情况，活锁和饥饿。</p>
<p>死锁是由于两个或多个线程都需要对方持有的资源，活锁正好相反，是由于谦让引起的。两个或多个线程，同一时间执行统一操作，发现冲突了，就再次重试，重试后依然冲突，就这样一直谦让下去。</p>
<p>解决活锁的问题比较容易，随机时间重试即可。数通，分布式一致性Raft算法，都是这么做的。</p>
<p>饥饿，是指线程一直得不到执行。发生饥饿一般有如下情况：</p>
<ul>
<li>公平性问题，线性因优先级低，在系统忙时一直得不到执行</li>
<li>长时间资源占用问题，线程等待某些资源，如IO，锁等，一直等不到，一直阻塞下去</li>
</ul>
<h5 id="33-性能问题">3.3 性能问题</h5>
<p>性能问题，一般都是由于锁的滥用引起的，比如，可以不用锁的地方，用了锁，本来可以用小锁的地方，用了大锁。根据不同场景，选择不同的最小互斥方案。</p>
<p>性能方面主要有三个主要指标：</p>
<ul>
<li>吞吐：指单位时间处理的请求数</li>
<li>时延：指单次处理的平均耗时</li>
<li>并发：同一时刻可以接入的请求数</li>
</ul>
<h2 id="二-线程与锁的基本使用">二. 线程与锁的基本使用</h2>
<h3 id="1-线程的基本操作">1. 线程的基本操作</h3>
<h5 id="11-线程的状态">1.1 线程的状态</h5>
<p>JDK中线程有五种状态：</p>
<ul>
<li>初始状态NEW：线程被创建，线程对象生成，即进入了初始状态NEW，这时只是生成了一个Java对象，操作系统和没有感知</li>
<li>可运行状态RUNNABLE：线程启动，操作系统已经感知，进入操作系统的线程调度框架，可以被分配CPU</li>
<li>运行状态RUNNING：当有CPU空闲时，操作系统线程调度系统分配CPU，线程进入运行状态，开始执行run代码</li>
<li>阻塞状态BLOCKED：线程在执行过程调用一个阻塞API或等待某个事件时，线程的状态就是进入阻塞状态，释放CPU；当执行条件满足时，如阻塞API返回、等待事件发生了，线程重新进入可运行状态，等待操作系统分配CPU</li>
<li>终止状态TERMINATED：线程结束运行，有三种情况可能使线程结束，run终止正常退出，收到stop/interrupt调用终止，线程异常退出</li>
</ul>
<p>
  <img src="/img/JUC/image-20210728214316162.png" alt="image-20210728214316162">

</p>
<h5 id="12-线程状态的切换">1.2 线程状态的切换</h5>
<p>以上是从操作系统的角度看的实际运行状态，Java语言层面的实现与此略有差异，Java语言中线程一共有六种状态：</p>
<ul>
<li>初始化状态 NEW</li>
<li>可运行状态 RUNNABLE</li>
<li>阻塞状态 BLOCKED</li>
<li>无限时等待状态 WAITING</li>
<li>有限时等待状态 TIMED WAITING</li>
<li>终止状态 TERMINATED</li>
</ul>
<p>Java把OS的可运行与运行状态合一，因为语言层面上控制不了；把阻塞状态拆分为三种状态：BLOCKED，WAITING，TIMED WAITING，对于不同阻塞场景，合并后的场景如下</p>
<p>
  <img src="/img/JUC/image-20210728215904492.png" alt="image-20210728215904492">

</p>
<h5 id="13-线程的基本使用">1.3 线程的基本使用</h5>
<p>创建线程的方法：Thread/Runnable</p>
<p>线程的启动方式：start()</p>
<p>线程的让渡方式：</p>
<ul>
<li>sleep：这是Thread的静态方法，一定要带超时参数，表示执行sleep的线程进入TIMED WAITING状态</li>
<li>yield：也是Thread的静态方法，表示暂时让渡CPU，从OS层面上看，线程从运行状态到可执行状态，重试等时间片；</li>
<li>join：Thread的对象方法，在threadA的run中调用threadB.join()，表示threadA等threadB执行结束</li>
</ul>
<p>线程的终止方法：</p>
<ul>
<li>stop：调用stop方法可以直接终止线程，但此方法已经被标记为@Deprecated，生成环境上也不能使用。因为stop过于粗暴，直接清除线程对象，没给线程任何机会清理线程的机会，如获取一个锁，还没来得及释放，就stop了，这个锁就再也没有机会释放了，这在生产环境上是不可以接受的。</li>
<li>interrupt：该方法通知线程需要终止了，线程收到这个通知，可以选择清理现场，结束任务，也可以选择继续执行（不建议）。线程获取interrupt的方式有两种，接受interruptedException异常与主动查看interrupt标志位。一些阻塞操作会抛出interrException如wait()、join()、sleep()等。同时，线程还提供了isInterrupt()方法，当执行线程的interr方法后，此方法返回true</li>
</ul>
<p>创建线程的目的是为了开启一条执行路径，去运行指定的代码和其他代码实现同时运行。而运行的指定代码就是这个执行路径的任务。Jvm创建的主线程的任务都定义在了主函数中。</p>
<p>而自定义的线程它的任务在哪呢？</p>
<p>Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务进行描述。这个任务就通过Thread类中的run方法来体现，也就是说，run方法就是封装自定义线程运行任务的函数。</p>
<h5 id="14-线程的优先级">1.4 线程的优先级</h5>
<ul>
<li>线程的优先级分为1~10共10个级别，1为最低级别，10为最高级别，在没有设置线程优先级的情况下，线程优先级默认为5</li>
<li>可以通过调用getPriority()方法获取指定线程的优先级：int i = t.getPriority();</li>
<li>我们也可以通过setPriority()方法去设置线程的优先级：t.setPriority(1~10);</li>
<li>线程优先级的高低并不决定线程的执行顺序（并不是优先级高的线程先执行优先级低的后执行），而是<strong>优先级高的线程具有更多的执行机会</strong></li>
</ul>
<h5 id="15-线程使用规范">1.5 线程使用规范</h5>
<ul>
<li>尽量不要直接创建线程，而是使用线程池，原因如下：线程的创建于销毁，有巨大的消耗；线程是一种系统资源，使用线程池可以管控线程资源</li>
<li>正确的启动线程，不要使用run方法</li>
<li>正确终止线程，不要使用stop</li>
<li>不要使用yield方法做线程同步，yield是不可靠的，只是暂时让线程重新等待，下次什么时候执行是不可控制的</li>
</ul>
<h3 id="2-sychronized与volatile">2. sychronized与volatile</h3>
<p>保证并发正确性的基本原语</p>
<h5 id="21-sychronized">2.1 sychronized</h5>
<p><a href="https://www.cnblogs.com/aspirant/p/11470858.html">https://www.cnblogs.com/aspirant/p/11470858.html</a></p>
<p>sychronized是解决Java原子性，可见性和有序性问题的基本原语，是一种同步锁。被sychronized修饰的代码，同一时间只有一个线程可以执行。执行完成后，对其他线程可见</p>
<blockquote>
<p>原子性：确保线程互斥的访问同步代码快</p>
<p>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>保证的</p>
<p>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”</p>
</blockquote>
<p>从语法上讲，Synchronized可以把任何一个非null对象作为&quot;锁&rdquo;，在HotSpot JVM实现中，<strong>锁有个专门的名字：对象监视器（Object Monitor）</strong>。</p>
<p>注意，synchronized 内置锁 是一种 对象锁（锁的是对象而非引用变量），<strong>作用粒度是对象 ，可以用来实现对 临界资源的同步互斥访问 ，是 可重入 的。其可重入最大的作用是避免死锁</strong></p>
<p>如：<strong>子类同步方法调用了父类同步方法，如没有可重入的特性，则会发生死锁</strong></p>
<p>用法：</p>
<ul>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其保护的范围是大括号{}括起来的代码，锁是sychronized的参数</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其保护的范围，是整个方法，锁是整个方法的this对象</li>
<li>修饰一个静态的方法，其作用的范围是整个静态方法，锁是这个类，即Class对象，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁；</li>
</ul>
<p>sychronized关键字与我们平常认识锁不一样，没有Lock对象，也没用Lock.lock，Lock.unlock方法，但其本质上就是同步锁，Lock对象和lock/unlock方法都是隐式的。</p>
<p>释放锁</p>
<ul>
<li>如果一个线程一直占用一个对象的锁，则其他的线程将永远无法访问该对象，因此，需要在适当的时候，将对象锁归还</li>
<li>当线程执行到synchronized()块结束时，释放对象锁</li>
<li>当在synchronized()块中遇到break, return或抛出exception，则自动释放对象锁</li>
<li>当一个线程调用wait()方法时，它放弃拥有的对象锁并进入等待队列</li>
</ul>
<h5 id="22-锁和受保护对象的关系">2.2 锁和受保护对象的关系</h5>
<p>对于任何锁，我们需要明白两个问题，我们的锁是什么？我们的锁保护的资源是什么？</p>
<p>锁和受保护的资源一个正确关系是：受保护资源与锁之间的N：1的关系，即一把锁可以保护多种资源，但一种资源，只能被一把锁保护</p>
<h5 id="23-volatile">2.3 volatile</h5>
<p>volatile并不是java独有的，C语言中也有次关键字</p>
<p>volatile用来修饰变量，对这个变量的操作，不要用CPU缓存，必须从内存中进行读取和写入。这样做的目的是解决可见性问题，达到的效果是一个线程对volatile变量的修改对其他后续线程可见。</p>
<p>使用volatile注意两个问题：</p>
<ol>
<li>volatile不能解决原子性问题，因此<strong>volatile long count = 0;<strong>后，两个线程做</strong>count++;</strong>，得不到正确结果。</li>
<li>volatile的使用很简单，但是和锁机制共同使用，就有复杂的可见性传递问题，这种问题需要对JMM及happen-before规则有一定了解才行</li>
</ol>
<p>基于以上两点，建议：使用volatile修饰的变量的修改操作，不能依赖其读操作；使用volatile修饰的变量，不能和其他变量有依赖关系，比如，只用volatile修饰用户配置</p>
<h3 id="3-线程同步等待与通知">3 线程同步：等待与通知</h3>
<p>线程同步的一个经典场景就是生产者与消费者模式，有了“等待-通知”机制，让我们避免了消费者去轮询</p>
<h5 id="31-监视器monitor">3.1 监视器（Monitor）</h5>
<p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实
现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。前面我们在讲Java对象头的时候，讲到了monitor这个对象，在hotspot虚拟机中，通过ObjectMonitor类来实现monitor。他的锁的获取过程的体现会简单很多.

  <img src="/img/JUC/1628329156704.png" alt="1628329156704">

</p>
<h5 id="32-wait-notify的使用方式">3.2 wait-notify的使用方式</h5>
<p>在Java中，可以通过调用Object类的wait()，notify()及notifyAll()方法实现线程间的同步，这几个方法只能在sychronized修饰的方法或代码中使用，线程在获取到锁后，执行到wait，就会释放所有的锁，同时线程进入阻塞状态，直到有线程调用notify或notifyAll方法</p>
<p>object是所有类的超类，因此wait/notify/notifyAll是每个对象都有的方法，这些方法被申明为final，所以是每个类不能改写的。</p>
<p>API详细说明：</p>
<ul>
<li>wait：该方法用来将当前线程置为休眠状态，直到接到通知或被中断为止</li>
<li>notify：该方法用来通知那些可能对待该对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait状态线程发出通知。notify后，当前线程不会马上释放该对象，wait所在的线程并不能马上获取到该锁，要等到程序退出sychronized代码块后，当前线程才会释放锁，wait线程也才可能获取到该锁</li>
<li>notifyAll：与notifyAll工作方式一致，但会通知所有进入阻塞队列的线程，如果其中一个线程获取到了该锁，他就继续往下执行，在他退出sychronized代码块后，其他的已经被唤醒的线程就会继续竞争获取该锁，椅子进行下去，直到所有被唤醒的线程都执行完毕</li>
</ul>
<h5 id="33-wait-notify的原理">3.3 wait-notify的原理</h5>
<p>Java语言内置的sychronized配置wait/notify/notifyAll可以轻松实现等待-通知机制。这种机制内部是使用队列实现的</p>
<ol>
<li>每个锁对象，有且仅有一个等待队列</li>
<li>线程获取锁后，进入临界区，发现条件不满足，则等待；此时，线程进入锁的等待队列，释放锁</li>
<li>其他线程获取锁后，使用之前的线程条件满足后，做notify操作，此时线程变为RUNNABLE状态，可以重新获取锁</li>
</ol>
<p>wait的执行原理</p>
<h3 id="4-线程的终止与关闭">4. 线程的终止与关闭</h3>
<h3 id="5-守护线程">5. 守护线程</h3>
<p>为用户线程进行服务的线程.当所有的用户线程都执行结束以后无论守护线程的线程体是否执行完,守护线程都会结束</p>
<p>设置守护线程</p>
<pre><code>void  setDaemon(boolean on) 将该线程标记为守护线程或用户线程。
boolean   isDaemon() 测试该线程是否为守护线程。
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">MyThread01</span> <span style="color:#8be9fd;font-style:italic">implements</span> Runnable <span style="color:#ff79c6">{</span>

   <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">run</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
      <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 1<span style="color:#ff79c6">;</span> i <span style="color:#ff79c6">&lt;=</span> 100<span style="color:#ff79c6">;</span> i<span style="color:#ff79c6">++)</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getName</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;~~~&#34;</span> <span style="color:#ff79c6">+</span> i<span style="color:#ff79c6">);</span>
      <span style="color:#ff79c6">}</span>
   <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">MyThread02</span> <span style="color:#8be9fd;font-style:italic">extends</span> Thread <span style="color:#ff79c6">{</span>
   <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">run</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
      <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 1<span style="color:#ff79c6">;</span> i <span style="color:#ff79c6">&lt;=</span> 100<span style="color:#ff79c6">;</span> i<span style="color:#ff79c6">++)</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">getName</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;*_*&#34;</span> <span style="color:#ff79c6">+</span> i<span style="color:#ff79c6">);</span>
      <span style="color:#ff79c6">}</span>
   <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Test</span> <span style="color:#ff79c6">{</span>
   <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">main</span><span style="color:#ff79c6">(</span>String<span style="color:#ff79c6">[]</span> args<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
      Thread t1 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Thread<span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> MyThread01<span style="color:#ff79c6">());</span>
      Thread t2 <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> MyThread02<span style="color:#ff79c6">();</span>
      <span style="color:#6272a4">// 把t2 设置为守护线程
</span><span style="color:#6272a4"></span>      <span style="color:#6272a4">// 守护线程:为用户线程进行服务的线程.当所有的用户线程都执行结束以后
</span><span style="color:#6272a4"></span>      <span style="color:#6272a4">// 无论守护线程的线程体是否执行完,守护线程都会结束
</span><span style="color:#6272a4"></span>      t2<span style="color:#ff79c6">.</span><span style="color:#50fa7b">setDaemon</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">true</span><span style="color:#ff79c6">);</span>
      t1<span style="color:#ff79c6">.</span><span style="color:#50fa7b">start</span><span style="color:#ff79c6">();</span>
      t2<span style="color:#ff79c6">.</span><span style="color:#50fa7b">start</span><span style="color:#ff79c6">();</span>
      <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 1<span style="color:#ff79c6">;</span> i <span style="color:#ff79c6">&lt;=</span> 100<span style="color:#ff79c6">;</span> i<span style="color:#ff79c6">++)</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getName</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;&lt;&gt;&lt;&gt;&#34;</span> <span style="color:#ff79c6">+</span> i<span style="color:#ff79c6">);</span>
      <span style="color:#ff79c6">}</span>
   <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>注意: main 线程是主线程，不是守护线程，也不能设置为守护线程。</p>
<h2 id="三-线程池与异步编程">三. 线程池与异步编程</h2>
<h3 id="1-executor线程池">1. Executor线程池</h3>
<h4 id="11-executor框架">1.1 Executor框架</h4>
<p>
  <img src="/img/JUC/gplznh8j4o.jpeg" alt="gplznh8j4o">

<a href="https://cloud.tencent.com/developer/article/1490403">https://cloud.tencent.com/developer/article/1490403</a></p>
<p>
  <img src="/img/JUC/1628389344012.png" alt="1628389344012">

</p>
<p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。从图中可以看出Exectuor下有一个重要的子接口ExecutorService，其中定义了线程池的具体行为：</p>
<ul>
<li>execute(Runnable runnable)：执行Runnable类型的任务</li>
<li>submit(task)：用来提交Callable或者Runnable任务，并返回代表此任务的Future对象</li>
<li>shutdown()：在完成已经提交的任务后封闭办事，不在接管新的任务</li>
<li>shutdownNow()：停止所有正在履行的任务并封闭办事</li>
<li>isTerminated()：是一个钩子函数，测试是否所有任务都履行完毕了</li>
<li>isShutdown()：是一个钩子函数，测试是否该ExecutorService是否被关闭</li>
</ul>
<h4 id="12-executor接口">1.2 Executor接口</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6272a4">/* 
</span><span style="color:#6272a4"> * @since 1.5
</span><span style="color:#6272a4"> * @author Doug Lea
</span><span style="color:#6272a4"> */</span>
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">interface</span> <span style="color:#50fa7b">Executor</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">execute</span><span style="color:#ff79c6">(</span>Runnable command<span style="color:#ff79c6">);</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务</p>
<h4 id="13-executorserver接口">1.3 ExecutorServer接口</h4>
<p>重要属性:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6272a4">// 对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它包含两部分信息：线程池的运行状态(runState)和线程池内有效线程的数量(workerCount)
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">final</span> AtomicInteger ctl <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> AtomicInteger<span style="color:#ff79c6">(</span>ctlOf<span style="color:#ff79c6">(</span>RUNNING<span style="color:#ff79c6">,</span> 0<span style="color:#ff79c6">));</span>
<span style="color:#6272a4">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">int</span> COUNT_BITS <span style="color:#ff79c6">=</span> Integer<span style="color:#ff79c6">.</span><span style="color:#50fa7b">SIZE</span> <span style="color:#ff79c6">-</span> 3<span style="color:#ff79c6">;</span>
<span style="color:#6272a4">// 000 11111111111111111111111111111
</span><span style="color:#6272a4">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">int</span> CAPACITY   <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">(</span>1 <span style="color:#ff79c6">&lt;&lt;</span> COUNT_BITS<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">-</span> 1<span style="color:#ff79c6">;</span>
</code></pre></div><p>这里可以看到，使用Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY 就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p>
<p>ctl相关方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6272a4">//获取运行状态，将整数 c 的低 29 位修改为 0，就得到了线程池的状态
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">runStateOf</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> c<span style="color:#ff79c6">)</span>     <span style="color:#ff79c6">{</span> <span style="color:#ff79c6">return</span> c <span style="color:#ff79c6">&amp;</span> <span style="color:#ff79c6">~</span>CAPACITY<span style="color:#ff79c6">;</span> <span style="color:#ff79c6">}</span>
<span style="color:#6272a4">//获取活动线程数，将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">workerCountOf</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> c<span style="color:#ff79c6">)</span>  <span style="color:#ff79c6">{</span> <span style="color:#ff79c6">return</span> c <span style="color:#ff79c6">&amp;</span> CAPACITY<span style="color:#ff79c6">;</span> <span style="color:#ff79c6">}</span>
<span style="color:#6272a4">//获取运行状态和活动线程数的值
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">ctlOf</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> rs<span style="color:#ff79c6">,</span> <span style="color:#8be9fd">int</span> wc<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span> <span style="color:#ff79c6">return</span> rs <span style="color:#ff79c6">|</span> wc<span style="color:#ff79c6">;</span> <span style="color:#ff79c6">}</span>
</code></pre></div><p>线程池的状态：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">RUNNING <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>1 <span style="color:#ff79c6">&lt;&lt;</span> COUNT_BITS; <span style="color:#6272a4">//高3位为111
</span><span style="color:#6272a4"></span>SHUTDOWN <span style="color:#ff79c6">=</span> 0 <span style="color:#ff79c6">&lt;&lt;</span> COUNT_BITS; <span style="color:#6272a4">//高3位为000
</span><span style="color:#6272a4"></span>STOP <span style="color:#ff79c6">=</span> 1 <span style="color:#ff79c6">&lt;&lt;</span> COUNT_BITS; <span style="color:#6272a4">//高3位为001
</span><span style="color:#6272a4"></span>TIDYING <span style="color:#ff79c6">=</span> 2 <span style="color:#ff79c6">&lt;&lt;</span> COUNT_BITS; <span style="color:#6272a4">//高3位为010
</span><span style="color:#6272a4"></span>TERMINATED <span style="color:#ff79c6">=</span> 3 <span style="color:#ff79c6">&lt;&lt;</span> COUNT_BITS; <span style="color:#6272a4">//高3位为011
</span></code></pre></div><p>
  <img src="/img/JUC/1628473972134.png" alt="1628473972134">

</p>
<p>1、RUNNING</p>
<ul>
<li>状态说明：线程池处于RUNNING状态，能够接收新任务，以及对已添加的任务进行处理。</li>
<li>状态切换：线程池的初始化状态是RUNNING。换句话说，线程池一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。</li>
</ul>
<p>2、SHUTDOWN</p>
<ul>
<li>状态说明：线程池处于SHUTDOWN状态，不接收新任务，能够处理已经添加的任务。</li>
<li>状态切换：调用shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN。</li>
</ul>
<p>3、STOP</p>
<ul>
<li>状态说明：线程池处于STOP状态，不接收新任务，不处理已提交的任务，并且会中断正在处理的任务。</li>
<li>状态切换：调用线程池中的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN) -&gt; STOP。</li>
</ul>
<p>4、TIDYING</p>
<ul>
<li>状态说明：当所有的任务已经停止，ctl记录“任务数量”为0，线程池会变为TIDYING状态。当线程池处于TIDYING状态时，会执行钩子函数 terminated()。terminated()在ThreadPoolExecutor类中是空 的，若用户想在线程池变为TIDYING时，进行相应处理，可以通过重载 terminated()函数来实现。</li>
<li>状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行任务也为空时，就会由SHUTDOWN -&gt; TIDYING。当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP-&gt; TIDYING。</li>
</ul>
<p>5、TERMINATED</p>
<ul>
<li>状态说明：线程池线程池彻底停止，线程池处于TERMINATED状态，</li>
<li>状态切换：线程池处于TIDYING状态时，执行完terminated()之后， 就会由TIDYING-&gt;TERMINATED。</li>
</ul>
<p>线程池使用：</p>
<p>RunTask类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">RunTask</span> <span style="color:#8be9fd;font-style:italic">implements</span> Runnable <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">run</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;Thread name:&#34;</span><span style="color:#ff79c6">+</span>Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getName</span><span style="color:#ff79c6">());</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>ExecutorSample类</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">ExecutorSample</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">main</span><span style="color:#ff79c6">(</span>String<span style="color:#ff79c6">[]</span> args<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        ExecutorService executor <span style="color:#ff79c6">=</span> Executors<span style="color:#ff79c6">.</span><span style="color:#50fa7b">newFixedThreadPool</span><span style="color:#ff79c6">(</span>5<span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i<span style="color:#ff79c6">=</span>0<span style="color:#ff79c6">;</span>i<span style="color:#ff79c6">&lt;</span>20<span style="color:#ff79c6">;</span>i<span style="color:#ff79c6">++){</span>
            <span style="color:#6272a4">//提交任务无返回值
</span><span style="color:#6272a4"></span>            executor<span style="color:#ff79c6">.</span><span style="color:#50fa7b">execute</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> RunTask<span style="color:#ff79c6">());</span>
            <span style="color:#6272a4">//任务执行完成后有返回值
</span><span style="color:#6272a4"></span>            Future<span style="color:#ff79c6">&lt;</span>Object<span style="color:#ff79c6">&gt;</span> future <span style="color:#ff79c6">=</span> executor<span style="color:#ff79c6">.</span><span style="color:#50fa7b">submit</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> RunTask<span style="color:#ff79c6">());</span>
        <span style="color:#ff79c6">}</span>
        <span style="color:#6272a4">//关闭线程池
</span><span style="color:#6272a4"></span>        executor<span style="color:#ff79c6">.</span><span style="color:#50fa7b">shutDown</span><span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。我们是往线程池提交任务（task）,我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池</p>
<h4 id="14-threadpoolexecutor">1.4 ThreadPoolExecutor</h4>
<p>自定义线程池的创建</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">ThreadPoolExecutor</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> corePoolSize<span style="color:#ff79c6">,</span>
                          <span style="color:#8be9fd">int</span> maximumPoolSize<span style="color:#ff79c6">,</span>
                          <span style="color:#8be9fd">long</span> keepAliveTime<span style="color:#ff79c6">,</span>
                          TimeUnit unit<span style="color:#ff79c6">,</span>
                          BlockingQueue<span style="color:#ff79c6">&lt;</span>Runnable<span style="color:#ff79c6">&gt;</span> workQueue<span style="color:#ff79c6">,</span>
                          ThreadFactory threadFactory<span style="color:#ff79c6">,</span>
                          RejectedExecutionHandler handler<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#ff79c6">this</span><span style="color:#ff79c6">(</span>corePoolSize<span style="color:#ff79c6">,</span> maximumPoolSize<span style="color:#ff79c6">,</span> keepAliveTime<span style="color:#ff79c6">,</span> unit<span style="color:#ff79c6">,</span> workQueue<span style="color:#ff79c6">,</span>
         threadFactory<span style="color:#ff79c6">,</span> defaultHandler<span style="color:#ff79c6">);</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><ul>
<li>corePoolSize：线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li>maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。</li>
<li>keepAliveTime：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize时候，如果这时候没有新的任务提交，核心线程外的线程不会立即被销毁，而是会等待，直到等待的时间超过了keepAliveTime unit：keepAliveTime的单位时间</li>
<li>workQueue：用于保存等待被执行的任务的阻塞队列，且任务必须实现Runnable接口，在JDK中提供了如下阻塞队列：ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务。LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue。SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue。</li>
<li>PriorityBlockingQueue：具有优先级的无界阻塞队列。</li>
<li>threadFactory：ThreadFactory 类型的变量，用来创建新线程。默认使用ThreadFactory.defaultThreadFactory来创建线程， 会使新创建线程具有相同的NORM_PRIORITY优先级并且都是非守护线程，同时也设置了线程名称。</li>
<li>handler：线程池的饱和策略。当阻塞队列满了，且没有空闲的工作队列，如果继续提交任务，必须采用一种策略处理该任务.</li>
</ul>
<p>线程池的监控：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">long</span> <span style="color:#50fa7b">getTaskCount</span><span style="color:#ff79c6">()</span> <span style="color:#6272a4">//线程池已执行与未执行的任务总数
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">long</span> <span style="color:#50fa7b">getCompletedTaskCount</span><span style="color:#ff79c6">()</span> <span style="color:#6272a4">//已完成的任务数
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">getPoolSize</span><span style="color:#ff79c6">()</span> <span style="color:#6272a4">//线程池当前的线程数
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">getActiveCount</span><span style="color:#ff79c6">()</span> <span style="color:#6272a4">//线程池中正在执行任务的线程数量
</span></code></pre></div><p>线程池的原理</p>
<p>
  <img src="/img/JUC/1628388981101.png" alt="1628388981101">

</p>
<ul>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意这一个步骤需要获取全局锁）。</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意这一个步骤需要获取全局锁）。</li>
<li>如果创建的新线程将使当前运行的线程超出maximumPoolSize，任务将被执行饱和策略。ThreadPoolExecutor 采用上述的设计思路，是为执行execute()方法时，尽可能避免获取全局锁(一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后，几乎所有的execute()方法调用都是在执行步骤2，而步骤2不需要获取全局锁。</li>
</ul>
<p>简易图</p>
<p>
  <img src="/img/JUC/1628475735869.png" alt="1628475735869">

</p>
<p>execute方法</p>
<p><a href="https://cloud.tencent.com/developer/article/1829838?from=article.detail.1490403">https://cloud.tencent.com/developer/article/1829838?from=article.detail.1490403</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">execute</span><span style="color:#ff79c6">(</span>Runnable command<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>command <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">)</span>
        <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> NullPointerException<span style="color:#ff79c6">();</span>
  
    <span style="color:#6272a4">// 前面说的那个表示 “线程池状态” 和 “线程数” 的整数
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> ctl<span style="color:#ff79c6">.</span><span style="color:#50fa7b">get</span><span style="color:#ff79c6">();</span>
  
    <span style="color:#6272a4">// 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>workerCountOf<span style="color:#ff79c6">(</span>c<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&lt;</span> corePoolSize<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#6272a4">// 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了
</span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 至于执行的结果，到时候会包装到 FutureTask 中。
</span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 返回 false 代表线程池不允许提交任务
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>addWorker<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">,</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">))</span>
            <span style="color:#ff79c6">return</span><span style="color:#ff79c6">;</span>
        c <span style="color:#ff79c6">=</span> ctl<span style="color:#ff79c6">.</span><span style="color:#50fa7b">get</span><span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">}</span>
    <span style="color:#6272a4">// 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了
</span><span style="color:#6272a4"></span>  
    <span style="color:#6272a4">// 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>isRunning<span style="color:#ff79c6">(</span>c<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;&amp;</span> workQueue<span style="color:#ff79c6">.</span><span style="color:#50fa7b">offer</span><span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
        <span style="color:#6272a4">/* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程
</span><span style="color:#6272a4">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程
</span><span style="color:#6272a4">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里
</span><span style="color:#6272a4">         */</span>
        <span style="color:#8be9fd">int</span> recheck <span style="color:#ff79c6">=</span> ctl<span style="color:#ff79c6">.</span><span style="color:#50fa7b">get</span><span style="color:#ff79c6">();</span>
        <span style="color:#6272a4">// 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(!</span> isRunning<span style="color:#ff79c6">(</span>recheck<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;&amp;</span> remove<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">))</span>
            reject<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">);</span>
        <span style="color:#6272a4">// 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程
</span><span style="color:#6272a4"></span>        <span style="color:#6272a4">// 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>workerCountOf<span style="color:#ff79c6">(</span>recheck<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">==</span> 0<span style="color:#ff79c6">)</span>
            addWorker<span style="color:#ff79c6">(</span><span style="color:#ff79c6">null</span><span style="color:#ff79c6">,</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
    <span style="color:#6272a4">// 如果 workQueue 队列满了，那么进入到这个分支
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 以 maximumPoolSize 为界创建新的 worker，
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(!</span>addWorker<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">,</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">))</span>
        reject<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">);</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>?</p>
<p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。
从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p>
<h4 id="15-worker内部类">1.5 Worker内部类</h4>
<p><strong>任务是 Runnable（内部变量名叫 task 或 command），线程是 Worker</strong></p>
<p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Worker</span>
    <span style="color:#8be9fd;font-style:italic">extends</span> AbstractQueuedSynchronizer
    <span style="color:#8be9fd;font-style:italic">implements</span> Runnable
<span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">long</span> serialVersionUID <span style="color:#ff79c6">=</span> 6138294804551838833L<span style="color:#ff79c6">;</span>

    <span style="color:#6272a4">// 这个是真正的线程，任务靠你啦
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">final</span> Thread thread<span style="color:#ff79c6">;</span>
    
    <span style="color:#6272a4">// 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了
</span><span style="color:#6272a4"></span>    Runnable firstTask<span style="color:#ff79c6">;</span>
    
    <span style="color:#6272a4">// 用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">volatile</span> <span style="color:#8be9fd">long</span> completedTasks<span style="color:#ff79c6">;</span>

 <span style="color:#6272a4">// Worker 只有这一个构造方法，传入 firstTask，也可以传 null
</span><span style="color:#6272a4"></span>    Worker<span style="color:#ff79c6">(</span>Runnable firstTask<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        setState<span style="color:#ff79c6">(-</span>1<span style="color:#ff79c6">);</span> <span style="color:#6272a4">// inhibit interrupts until runWorker
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">firstTask</span> <span style="color:#ff79c6">=</span> firstTask<span style="color:#ff79c6">;</span>
        <span style="color:#6272a4">// 调用 ThreadFactory 来创建一个新的线程
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">this</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">thread</span> <span style="color:#ff79c6">=</span> getThreadFactory<span style="color:#ff79c6">().</span><span style="color:#50fa7b">newThread</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">this</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#6272a4">// 这里调用了外部类的 runWorker 方法
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">run</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
        runWorker<span style="color:#ff79c6">(</span><span style="color:#ff79c6">this</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>

 <span style="color:#ff79c6">...</span><span style="color:#6272a4">// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">}</span>
</code></pre></div><h4 id="16-executor工具类">1.6 Executor工具类</h4>
<ul>
<li>
<p>newFixedThreadPool：最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p>
</li>
<li>
<p>newSingleThreadExecutor：将newFixedThreadPool的线程数设置为1即可。</p>
</li>
<li>
<p>newCachedThreadPool：核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</p>
<p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p>
<p>我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支创建新线程。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> ctl<span style="color:#ff79c6">.</span><span style="color:#50fa7b">get</span><span style="color:#ff79c6">();</span>
<span style="color:#6272a4">// corePoolSize 为 0，所以不会进到这个 if 分支
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>workerCountOf<span style="color:#ff79c6">(</span>c<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&lt;</span> corePoolSize<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>addWorker<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">,</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">))</span>
        <span style="color:#ff79c6">return</span><span style="color:#ff79c6">;</span>
    c <span style="color:#ff79c6">=</span> ctl<span style="color:#ff79c6">.</span><span style="color:#50fa7b">get</span><span style="color:#ff79c6">();</span>
<span style="color:#ff79c6">}</span>
<span style="color:#6272a4">// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>isRunning<span style="color:#ff79c6">(</span>c<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;&amp;</span> workQueue<span style="color:#ff79c6">.</span><span style="color:#50fa7b">offer</span><span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd">int</span> recheck <span style="color:#ff79c6">=</span> ctl<span style="color:#ff79c6">.</span><span style="color:#50fa7b">get</span><span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(!</span> isRunning<span style="color:#ff79c6">(</span>recheck<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;&amp;</span> remove<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">))</span>
        reject<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>workerCountOf<span style="color:#ff79c6">(</span>recheck<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">==</span> 0<span style="color:#ff79c6">)</span>
        addWorker<span style="color:#ff79c6">(</span><span style="color:#ff79c6">null</span><span style="color:#ff79c6">,</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">);</span>
<span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(!</span>addWorker<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">,</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">))</span>
    reject<span style="color:#ff79c6">(</span>command<span style="color:#ff79c6">);</span>
</code></pre></div></li>
</ul>
<p>部分源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> ExecutorService <span style="color:#50fa7b">newCachedThreadPool</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">new</span> ThreadPoolExecutor<span style="color:#ff79c6">(</span>0<span style="color:#ff79c6">,</span> Integer<span style="color:#ff79c6">.</span><span style="color:#50fa7b">MAX_VALUE</span><span style="color:#ff79c6">,</span>
                                      60L<span style="color:#ff79c6">,</span> TimeUnit<span style="color:#ff79c6">.</span><span style="color:#50fa7b">SECONDS</span><span style="color:#ff79c6">,</span>
                                      <span style="color:#ff79c6">new</span> SynchronousQueue<span style="color:#ff79c6">&lt;</span>Runnable<span style="color:#ff79c6">&gt;());</span>
    <span style="color:#ff79c6">}</span>
    
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> ExecutorService <span style="color:#50fa7b">newFixedThreadPool</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> nThreads<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">new</span> ThreadPoolExecutor<span style="color:#ff79c6">(</span>nThreads<span style="color:#ff79c6">,</span> nThreads<span style="color:#ff79c6">,</span>
                                      0L<span style="color:#ff79c6">,</span> TimeUnit<span style="color:#ff79c6">.</span><span style="color:#50fa7b">MILLISECONDS</span><span style="color:#ff79c6">,</span>
                                      <span style="color:#ff79c6">new</span> LinkedBlockingQueue<span style="color:#ff79c6">&lt;</span>Runnable<span style="color:#ff79c6">&gt;());</span>
    <span style="color:#ff79c6">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> ExecutorService <span style="color:#50fa7b">newSingleThreadExecutor</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">new</span> FinalizableDelegatedExecutorService
            <span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> ThreadPoolExecutor<span style="color:#ff79c6">(</span>1<span style="color:#ff79c6">,</span> 1<span style="color:#ff79c6">,</span>
                                    0L<span style="color:#ff79c6">,</span> TimeUnit<span style="color:#ff79c6">.</span><span style="color:#50fa7b">MILLISECONDS</span><span style="color:#ff79c6">,</span>
                                    <span style="color:#ff79c6">new</span> LinkedBlockingQueue<span style="color:#ff79c6">&lt;</span>Runnable<span style="color:#ff79c6">&gt;()));</span>
    <span style="color:#ff79c6">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> ScheduledExecutorService <span style="color:#50fa7b">newScheduledThreadPool</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> corePoolSize<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">new</span> ScheduledThreadPoolExecutor<span style="color:#ff79c6">(</span>corePoolSize<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
    
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">ScheduledThreadPoolExecutor</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> corePoolSize<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd;font-style:italic">super</span><span style="color:#ff79c6">(</span>corePoolSize<span style="color:#ff79c6">,</span> Integer<span style="color:#ff79c6">.</span><span style="color:#50fa7b">MAX_VALUE</span><span style="color:#ff79c6">,</span> 0<span style="color:#ff79c6">,</span> NANOSECONDS<span style="color:#ff79c6">,</span>
              <span style="color:#ff79c6">new</span> DelayedWorkQueue<span style="color:#ff79c6">());</span>
    <span style="color:#ff79c6">}</span>
</code></pre></div><h4 id="17-blockingqueue阻塞队列">1.7 BlockingQueue阻塞队列</h4>
<ul>
<li>SynchronousQueue 是一个比较特殊的 BlockingQueue，其本身不储存任何元素，它有一个虚拟队列（或虚拟栈），不管读操作还是写操作，如果当前队列中存储的是与当前操作相同模式的线程，那么当前操作也进入队列中等待；如果是相反模式，则配对成功，从当前队列中取队头节点</li>
</ul>
<h4 id="18-rejectedexecutionhandler拒绝策略">1.8 RejectedExecutionHandler拒绝策略</h4>
<h3 id="2-创建多少线程池合适amdah定律">2. 创建多少线程池合适：Amdah定律</h3>
<h3 id="3-future异步编程基础">3. Future：异步编程基础</h3>
<p>异步编程场景</p>
<p><a href="https://cloud.tencent.com/developer/article/1558986">https://cloud.tencent.com/developer/article/1558986</a></p>
<p>在日常开发中我们经常会遇到这样的情况，就是需要异步的处理一些事情，而不需要知道异步任务的结果；比如在调用线程里面异步打日志，为了不让日志打印阻塞调用线程，会把日志设置为异步方式。如下图1-2-1日志异步化打印，使用一个内存队列把日志打印异步化，使用单一线程来消费队列里面日志事件执行具体的日志落盘操作（本质是一个多生产单消费模型），这种情况下调用线程把日志任务放入队列后就继续去干自己的事情了，而不再关心日志任务具体是什么时候入盘的；</p>
<p>
  <img src="/img/JUC/1628481185935.png" alt="1628481185935">

</p>
<p>在Java中每当我们需要执行异步任务的时候我们可以直接开启一个线程来实现，也可以把异步任务封装为任务对象投递到线程池里面来执行，在Spring框架中则提供了@Async注解把一个任务异步化来进行处理，这些内容会在后面章节具体讲解。</p>
<p>另外有时候我们还需要在主线程等待异步任务的执行结果，这时候Future就排上用场了；比如调用线程要等执行任务A执行完毕后在顺序执行任务B，并且把两者结果拼接起来作为前端展示使用，如果调用线程是同步调用两次查询（如下图1-2-2同步调用），则整个过程耗时时间为执行任务A的耗时加上执行任务B的耗时。</p>
<p>
  <img src="/img/JUC/1628481518264.png" alt="1628481518264">

</p>
<p>如果使用异步编程（如下图1-2-3）则可以在调用线程内开启一个异步运行单元来执行任务A，开启异步运行单元后调用线程会马上返回一个Future对象（futureB），然后调用线程本身来执行任务B，等任务B执行完毕后，调用线程可以调用futureB的get（）方法获取任务A的执行结果，最后在拼接两者结果。这时由于任务A和任务B是并行运行的，所以整个过程耗时为max(调用线程执行任务B耗时，异步运行单元执行任务A耗时）。</p>
<p>
  <img src="/img/JUC/1628481557134.png" alt="1628481557134">

</p>
<h3 id="4-completablefuture">4. CompletableFuture</h3>
<p>使用Future确实可以获取异步任务的执行结果，但是获取其结果还是会阻塞调用线程的，并没有实现完全异步化处理，在JDK8中提供了CompletableFuture来弥补了其缺点。CompletableFuture类允许以非阻塞方式和基于通知的方式处理结果，其通过设置回调函数方式，让主线程彻底解放出来，做自己的事情，实现了实际意义上的异步处理；</p>
<p>如下图1-2-4使用CompletableFuture时候当异步单元返回futureB后，调用线程可以在其上调用whenComplete方法设置一个回调函数action,然后调用线程就会马上返回了，等异步任务执行完毕后会使用异步线程来执行回调函数action，而无需调用线程干预，如果你对CompletableFuture不了解，没关系，后面章节我们会详细讲解，这里你只需要知道其解决了传统Future的缺陷就可以了。</p>
<p>
  <img src="/img/JUC/1628481647750.png" alt="1628481647750">

</p>
<h3 id="5-completionserver">5. CompletionServer</h3>
<p>JDK8还引入了Stream，它旨在有效地处理数据流（包括原始类型），其使用声明式编程让我们可以写出可读性、可维护性很强的代码，并且结合CompletableFuture可以完美的实现异步编程。但是它产生的流只能使用一次，并且缺少与时间相关的操作（例如RxJava中的基于时间窗口的缓存元素），虽然可以执行并行计算，但无法指定要使用的线程池。并且它还没有设计用于处理延迟的操作（例如RxJava中的defer操作）；而Reactor或RxJava等Reactive API就是为了解决这些问题而生的。</p>
<p>Reactor或RxJava等反应式API也提供Java 8 Stream的运算符，但它们更适用于任何流序列（不仅仅是集合），并允许定义一个转换操作的管道，该管道将应用于通过它的数据，这要归功于方便的流畅API和Lambda表达式的使用。Reactive旨在处理同步或异步操作，并允许您缓冲（buffer）、合并（merge）、连接(join) 元素等对元素做各种转换。</p>
<p>上面我们讲解了单JVM内的异步编程，那么对于跨网络的交互是否也存在异步编程范畴那？对于网络请求来说，同步调用时比较直截了当的，比如我们在一个线程A中通过RPC请求获取服务B和服务C的数据，然后基于两者结果做一些事情。在同步调用情况下，线程A需要调用服务B，然后需要同步等待服务B结果返回后，才可以对服务C发起调用，然后等服务C结果返回后才可以结合服务B和C的结果做一件事,如下图1-2-5：</p>
<p>
  <img src="/img/JUC/1628481733634.png" alt="1628481733634">

</p>
<h2 id="四-并发工具类">四. 并发工具类</h2>
<h3 id="1-reentrantlock与condition">1. ReentrantLock与Condition</h3>
<p>ReentrantLock底层使用了CAS+AQS队列实现，默认非公平锁。</p>
<p>ReentrantLock的2个构造函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">ReentrantLock</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
    sync <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> NonfairSync<span style="color:#ff79c6">();</span> <span style="color:#6272a4">//默认，非公平
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">}</span>
 
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#50fa7b">ReentrantLock</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">boolean</span> fair<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    sync <span style="color:#ff79c6">=</span> fair <span style="color:#ff79c6">?</span> <span style="color:#ff79c6">new</span> FairSync<span style="color:#ff79c6">()</span> <span style="color:#ff79c6">:</span> <span style="color:#ff79c6">new</span> NonfairSync<span style="color:#ff79c6">();</span> <span style="color:#6272a4">//根据参数创建
</span><span style="color:#6272a4"></span><span style="color:#ff79c6">}</span>
</code></pre></div><ol>
<li>
<p>ReentrantLock先通过CAS尝试获取锁</p>
</li>
<li>
<p>如果此时锁已经被占用，该线程加入AQS队列并wait()</p>
</li>
<li>
<p>当前驱线程的锁被释放，挂在CLH队列为首的线程就会被notify()，然后继续CAS尝试获取锁，</p>
<p>此时：</p>
<p>非公平锁，如果有其他线程尝试lock()，有可能被其他刚好申请锁的线程<strong>抢占</strong>。</p>
<p>公平锁，只有在CLH<strong>队列头的线程</strong>才可以获取锁，<strong>新来的线程</strong>只能插入到队尾。</p>
</li>
</ol>
<h4 id="11-公平锁和非公平锁">1.1 公平锁和非公平锁</h4>
<p>
  <img src="/img/JUC/image-20210811104501914.png" alt="image-20210811104501914">

</p>
<p>state</p>
<p>要完成互斥的功能，需要一个共同去抢占的值，这里采用了AQS中的state，当线程获取锁时，成功修改state值的线程，获得了锁，可以执行程序，此时也会记录当前线程，在此线程内，需要再次获得这个锁的时候，就避免了再次抢占的操作。故如下</p>
<ul>
<li>无线程持有时，state为0</li>
<li>当有线程持有时，state增长1，此时其他线程无法持有直到被释放</li>
<li>释放锁时，state减少1 当state恢复为0时，其他线程又可以进行抢占</li>
<li>当某个已经占用锁的线程再次获取到锁时，state再增长，为重入锁 A &mdash;&ndash;&gt; (+) state (-) &mdash;&mdash;&gt; A B &mdash;&ndash;&gt; (+) state (-) &mdash;&mdash;&gt; B C &mdash;&ndash;&gt; (+) state (-) &mdash;&mdash;&gt; C</li>
</ul>
<p>当然在修改state时，使用了cas修改，保证原子性</p>
<p>Node</p>
<p>当一个线程获取锁时，其他线程处于等待状态，需要这样的容器来存储这些数据，所有有了Node，一个Node代表一个线程（除头结点外） Node属性</p>
<ul>
<li>prev 指向上一节点</li>
<li>next 指向下一节点</li>
<li>thread 当前线程</li>
<li>waitStatus 等待状态</li>
</ul>
<p>Lock/Unlock</p>
<p><a href="https://cloud.tencent.com/developer/article/1687342">https://cloud.tencent.com/developer/article/1687342</a></p>
<p>非公平锁</p>
<p>直接调用CAS。如果成功通过CAS修改了state，指定当前线程为该锁的独占线程，标志自己成功获取锁。</p>
<p>如果CAS失败的话，调用acquire();</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">NonfairSync</span> <span style="color:#8be9fd;font-style:italic">extends</span> Sync <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">long</span> serialVersionUID <span style="color:#ff79c6">=</span> 7316153563782823691L<span style="color:#ff79c6">;</span>

        <span style="color:#6272a4">/**
</span><span style="color:#6272a4">         * Performs lock.  Try immediate barge, backing up to normal
</span><span style="color:#6272a4">         * acquire on failure.
</span><span style="color:#6272a4">         */</span>
        <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">lock</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>compareAndSetState<span style="color:#ff79c6">(</span>0<span style="color:#ff79c6">,</span> 1<span style="color:#ff79c6">))</span>
                setExclusiveOwnerThread<span style="color:#ff79c6">(</span>Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">());</span>
            <span style="color:#ff79c6">else</span>
                acquire<span style="color:#ff79c6">(</span>1<span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">}</span>

        <span style="color:#8be9fd;font-style:italic">protected</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">tryAcquire</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> acquires<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
            <span style="color:#ff79c6">return</span> nonfairTryAcquire<span style="color:#ff79c6">(</span>acquires<span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span>

<span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">nonfairTryAcquire</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> acquires<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
            <span style="color:#8be9fd;font-style:italic">final</span> Thread current <span style="color:#ff79c6">=</span> Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">();</span>
            <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> getState<span style="color:#ff79c6">();</span>
            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>c <span style="color:#ff79c6">==</span> 0<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
                <span style="color:#6272a4">// 新的线程可能抢占已经排队的线程的锁的使用权
</span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>compareAndSetState<span style="color:#ff79c6">(</span>0<span style="color:#ff79c6">,</span> acquires<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
                    setExclusiveOwnerThread<span style="color:#ff79c6">(</span>current<span style="color:#ff79c6">);</span>
                    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
                <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>current <span style="color:#ff79c6">==</span> getExclusiveOwnerThread<span style="color:#ff79c6">())</span> <span style="color:#ff79c6">{</span>
                <span style="color:#8be9fd">int</span> nextc <span style="color:#ff79c6">=</span> c <span style="color:#ff79c6">+</span> acquires<span style="color:#ff79c6">;</span>
                <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>nextc <span style="color:#ff79c6">&lt;</span> 0<span style="color:#ff79c6">)</span> <span style="color:#6272a4">// overflow
</span><span style="color:#6272a4"></span>                    <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> Error<span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;Maximum lock count exceeded&#34;</span><span style="color:#ff79c6">);</span>
                setState<span style="color:#ff79c6">(</span>nextc<span style="color:#ff79c6">);</span>
                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
            <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>
</code></pre></div><p>公平锁</p>
<p>首先，调用<strong>tryAcquire()</strong>，会尝试再次通过CAS修改state为1。</p>
<p>如果失败而且发现锁是被当前线程占用的，就执行重入（state++）；</p>
<p>如果锁是被其他线程占有，那么当前线程执行tryAcquire返回失败，并且执行addWaiter()进入等待队列，并挂起自己interrupt()。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">FairSync</span> <span style="color:#8be9fd;font-style:italic">extends</span> Sync <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">long</span> serialVersionUID <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>3000897897090466540L<span style="color:#ff79c6">;</span>

        <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">lock</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
            acquire<span style="color:#ff79c6">(</span>1<span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">}</span>

        <span style="color:#6272a4">/**
</span><span style="color:#6272a4">         * Fair version of tryAcquire.  Don&#39;t grant access unless
</span><span style="color:#6272a4">         * recursive call or no waiters or is first.
</span><span style="color:#6272a4">         */</span>
        <span style="color:#8be9fd;font-style:italic">protected</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">tryAcquire</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> acquires<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
            <span style="color:#8be9fd;font-style:italic">final</span> Thread current <span style="color:#ff79c6">=</span> Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">();</span>
            <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> getState<span style="color:#ff79c6">();</span>
            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>c <span style="color:#ff79c6">==</span> 0<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
                <span style="color:#6272a4">//!hasQueuedPredecessors()保证了不论是新的线程还是已经排队的线程都顺序使用锁
</span><span style="color:#6272a4"></span>                <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(!</span>hasQueuedPredecessors<span style="color:#ff79c6">()</span> <span style="color:#ff79c6">&amp;&amp;</span>
                    compareAndSetState<span style="color:#ff79c6">(</span>0<span style="color:#ff79c6">,</span> acquires<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
                    setExclusiveOwnerThread<span style="color:#ff79c6">(</span>current<span style="color:#ff79c6">);</span>
                    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
                <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>current <span style="color:#ff79c6">==</span> getExclusiveOwnerThread<span style="color:#ff79c6">())</span> <span style="color:#ff79c6">{</span>
                <span style="color:#8be9fd">int</span> nextc <span style="color:#ff79c6">=</span> c <span style="color:#ff79c6">+</span> acquires<span style="color:#ff79c6">;</span>
                <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>nextc <span style="color:#ff79c6">&lt;</span> 0<span style="color:#ff79c6">)</span>
                    <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> Error<span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;Maximum lock count exceeded&#34;</span><span style="color:#ff79c6">);</span>
                setState<span style="color:#ff79c6">(</span>nextc<span style="color:#ff79c6">);</span>
                <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
            <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span>


<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">acquire</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> arg<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(!</span>tryAcquire<span style="color:#ff79c6">(</span>arg<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;&amp;</span>
            acquireQueued<span style="color:#ff79c6">(</span>addWaiter<span style="color:#ff79c6">(</span>Node<span style="color:#ff79c6">.</span><span style="color:#50fa7b">EXCLUSIVE</span><span style="color:#ff79c6">),</span> arg<span style="color:#ff79c6">))</span>
            selfInterrupt<span style="color:#ff79c6">();</span>
    <span style="color:#ff79c6">}</span>
</code></pre></div><p>两者区别</p>
<p>这里需要注意，公平锁和非公平锁的区别所在：调用lock()函数的时候，</p>
<p>非公平直接采用cas去获取锁，如果失败再去调用acquire(1)，acquire(1)再调用tryAcquire();</p>
<p>公平锁则会先调用acquire(1)，acquire(1)再调用tryAcquire()。</p>
<p>addWaiter()</p>
<p>当前线程加入AQS双向链表队列。</p>
<p>写入之前需要将当前线程包装为一个 Node 对象(addWaiter(Node.EXCLUSIVE))。</p>
<p>首先判断队列是否为空，不为空时则将封装好的 Node 利用 CAS 写入队尾；</p>
<p>如果队列为空（尾结点为null）或者出现并发写入失败的话，就需要调用 enq(node) 来写入了</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6272a4">/**
</span><span style="color:#6272a4"> * 将新节点和当前线程关联并且入队列
</span><span style="color:#6272a4"> * @param mode 独占/共享
</span><span style="color:#6272a4"> * @return 新节点
</span><span style="color:#6272a4"> */</span>
<span style="color:#8be9fd;font-style:italic">private</span> Node <span style="color:#50fa7b">addWaiter</span><span style="color:#ff79c6">(</span>Node mode<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">//初始化节点,设置关联线程和模式(独占 or 共享)
</span><span style="color:#6272a4"></span>    Node node <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Node<span style="color:#ff79c6">(</span>Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">(),</span> mode<span style="color:#ff79c6">);</span>
    <span style="color:#6272a4">// 获取尾节点引用
</span><span style="color:#6272a4"></span>    Node pred <span style="color:#ff79c6">=</span> tail<span style="color:#ff79c6">;</span>
    <span style="color:#6272a4">// 尾节点不为空,说明队列已经初始化过
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>pred <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        node<span style="color:#ff79c6">.</span><span style="color:#50fa7b">prev</span> <span style="color:#ff79c6">=</span> pred<span style="color:#ff79c6">;</span>
        <span style="color:#6272a4">// 设置新节点为尾节点
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>compareAndSetTail<span style="color:#ff79c6">(</span>pred<span style="color:#ff79c6">,</span> node<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
            pred<span style="color:#ff79c6">.</span><span style="color:#50fa7b">next</span> <span style="color:#ff79c6">=</span> node<span style="color:#ff79c6">;</span>
            <span style="color:#ff79c6">return</span> node<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span>
    <span style="color:#6272a4">// 尾节点为空,说明队列还未初始化,需要初始化head节点并入队新节点
</span><span style="color:#6272a4"></span>    enq<span style="color:#ff79c6">(</span>node<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">return</span> node<span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>

<span style="color:#8be9fd;font-style:italic">private</span> Node <span style="color:#50fa7b">enq</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd;font-style:italic">final</span> Node node<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(;;)</span> <span style="color:#ff79c6">{</span>
        Node t <span style="color:#ff79c6">=</span> tail<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>t <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span> <span style="color:#6272a4">// Must initialize
</span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>compareAndSetHead<span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> Node<span style="color:#ff79c6">()))</span>
                tail <span style="color:#ff79c6">=</span> head<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span> <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">{</span>
            node<span style="color:#ff79c6">.</span><span style="color:#50fa7b">prev</span> <span style="color:#ff79c6">=</span> t<span style="color:#ff79c6">;</span>
            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>compareAndSetTail<span style="color:#ff79c6">(</span>t<span style="color:#ff79c6">,</span> node<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
                t<span style="color:#ff79c6">.</span><span style="color:#50fa7b">next</span> <span style="color:#ff79c6">=</span> node<span style="color:#ff79c6">;</span>
                <span style="color:#ff79c6">return</span> t<span style="color:#ff79c6">;</span>
            <span style="color:#ff79c6">}</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>acquiredQueued()</p>
<p>写入队列后，需要挂起当前线程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">acquireQueued</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd;font-style:italic">final</span> Node node<span style="color:#ff79c6">,</span> <span style="color:#8be9fd">int</span> arg<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd">boolean</span> failed <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">try</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">boolean</span> interrupted <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">for</span> <span style="color:#ff79c6">(;;)</span> <span style="color:#ff79c6">{</span>
            <span style="color:#8be9fd;font-style:italic">final</span> Node p <span style="color:#ff79c6">=</span> node<span style="color:#ff79c6">.</span><span style="color:#50fa7b">predecessor</span><span style="color:#ff79c6">();</span>
            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>p <span style="color:#ff79c6">==</span> head <span style="color:#ff79c6">&amp;&amp;</span> tryAcquire<span style="color:#ff79c6">(</span>arg<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
                setHead<span style="color:#ff79c6">(</span>node<span style="color:#ff79c6">);</span>
                p<span style="color:#ff79c6">.</span><span style="color:#50fa7b">next</span> <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">;</span> <span style="color:#6272a4">// help GC
</span><span style="color:#6272a4"></span>                failed <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
                <span style="color:#ff79c6">return</span> interrupted<span style="color:#ff79c6">;</span>
            <span style="color:#ff79c6">}</span>
            <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>shouldParkAfterFailedAcquire<span style="color:#ff79c6">(</span>p<span style="color:#ff79c6">,</span> node<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;&amp;</span>
                parkAndCheckInterrupt<span style="color:#ff79c6">())</span>
                interrupted <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span> <span style="color:#ff79c6">finally</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>failed<span style="color:#ff79c6">)</span>
            cancelAcquire<span style="color:#ff79c6">(</span>node<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>首先会根据 <strong>node.predecessor()</strong> 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取成功就万事大吉了。</p>
<p>如果不是头节点，或者获取锁失败，则会根据上一个节点的 waitStatus 状态来处理(shouldParkAfterFailedAcquire(p, node))。</p>
<p>waitStatus 用于记录当前节点的状态，如节点取消、节点等待等。</p>
<p>shouldParkAfterFailedAcquire(p, node) 返回当前线程是否需要挂起，如果需要则调用 parkAndCheckInterrupt()：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">parkAndCheckInterrupt</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
    LockSupport<span style="color:#ff79c6">.</span><span style="color:#50fa7b">park</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">this</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">return</span> Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">interrupted</span><span style="color:#ff79c6">();</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>他是利用 <code>LockSupport</code> 的 <code>part</code> 方法来挂起当前线程的，直到被唤醒。</p>
<p>unlock</p>
<p>释放时候，state&ndash;，通过state==0判断锁是否完全被释放。</p>
<p>成功释放锁的话，唤起一个被挂起的线程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">unlock</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
    sync<span style="color:#ff79c6">.</span><span style="color:#50fa7b">release</span><span style="color:#ff79c6">(</span>1<span style="color:#ff79c6">);</span>
<span style="color:#ff79c6">}</span>
<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">release</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> arg<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>tryRelease<span style="color:#ff79c6">(</span>arg<span style="color:#ff79c6">))</span> <span style="color:#ff79c6">{</span>
        Node h <span style="color:#ff79c6">=</span> head<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>h <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&amp;&amp;</span> h<span style="color:#ff79c6">.</span><span style="color:#50fa7b">waitStatus</span> <span style="color:#ff79c6">!=</span> 0<span style="color:#ff79c6">)</span>
        	   <span style="color:#6272a4">//唤醒被挂起的线程
</span><span style="color:#6272a4"></span>            unparkSuccessor<span style="color:#ff79c6">(</span>h<span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>
<span style="color:#6272a4">//尝试释放锁
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">protected</span> <span style="color:#8be9fd;font-style:italic">final</span> <span style="color:#8be9fd">boolean</span> <span style="color:#50fa7b">tryRelease</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> releases<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> getState<span style="color:#ff79c6">()</span> <span style="color:#ff79c6">-</span> releases<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>Thread<span style="color:#ff79c6">.</span><span style="color:#50fa7b">currentThread</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">!=</span> getExclusiveOwnerThread<span style="color:#ff79c6">())</span>
        <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> IllegalMonitorStateException<span style="color:#ff79c6">();</span>
    <span style="color:#8be9fd">boolean</span> free <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">false</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">if</span> <span style="color:#ff79c6">(</span>c <span style="color:#ff79c6">==</span> 0<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        free <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">true</span><span style="color:#ff79c6">;</span>
        setExclusiveOwnerThread<span style="color:#ff79c6">(</span><span style="color:#ff79c6">null</span><span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>
    setState<span style="color:#ff79c6">(</span>c<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">return</span> free<span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>总结</p>
<ol>
<li>每一个ReentrantLock自身维护一个AQS队列记录申请锁的线程信息；</li>
<li>通过大量CAS保证多个线程竞争锁的时候的并发安全；</li>
<li>可重入的功能是通过维护state变量来记录重入次数实现的。</li>
<li>公平锁需要维护队列，通过AQS队列的先后顺序获取锁，缺点是会造成大量线程上下文切换；</li>
<li>非公平锁可以直接抢占，所以效率更高；</li>
</ol>
<h3 id="42-readwritelock与stampedlock">4.2 ReadWriteLock与StampedLock</h3>
<h3 id="43-semaphore保证池化资源">4.3 Semaphore：保证池化资源</h3>
<h3 id="44-countdownlatch与cyclicbarrier">4.4 CountDownLatch与CyclicBarrier</h3>
<h3 id="45-并发容器">4.5 并发容器</h3>
<h3 id="46-原子类与cas">4.6 原子类与CAS</h3>
<h3 id="47-分工的实现与forkjoin">4.7 分工的实现与Fork/Join</h3>
<h2 id="5-java并发模式">5. Java并发模式</h2>
<h3 id="51-immutability模式">5.1 Immutability模式</h3>
<h3 id="52-copyonwrite模式">5.2 CopyOnWrite模式</h3>
<h3 id="53-线程本地存储模式">5.3 线程本地存储模式</h3>
<h3 id="54-生产者与消费者模式">5.4 生产者与消费者模式</h3>
<h3 id="55-workerthread模式">5.5 WorkerThread模式</h3>
<h2 id="附录">附录</h2>
<h3 id="java内存模型">Java内存模型</h3>
<h3 id="同步器的基本实现aqs">同步器的基本实现AQS</h3>
<p><a href="https://blog.csdn.net/java_lyvee/article/details/98966684">https://blog.csdn.net/java_lyvee/article/details/98966684</a></p>
<p>AQS是一个用于构建锁和同步容器的框架。</p>
<p>AQS使用一个FIFO的队列（也叫CLH队列，是<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/claram/article/details/83828768">CLH锁</a>的一种变形），表示排队<strong>等待锁的线程</strong>。队列<strong>头节点</strong>称作“哨兵节点”或者“哑节点”，它不与任何线程关联。<strong>其他的节点</strong>与等待线程关联，每个节点维护一个等待状态waitStatus。结构如下图所示：</p>
<p>
  <img src="/img/JUC/image-20210809125719581.png" alt="image-20210809125719581">

</p>
<p>this逃逸问题</p>
<p>《Java异步编程实战》</p>
<p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。</p>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/jvm/" data-toggle="tooltip" data-placement="top" title="JVM">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/java" title="java">
                            java
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yuandaiqi@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/echocogito">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/yourstackoverflowid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
            
            
            
           
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Scavenger Blog 2022
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>









<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>

<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Scavenger Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://echocogito.github.io//img/home-page-yinyeshasgoy.jpg">
    <meta property="twitter:image" content="https://echocogito.github.io//img/home-page-yinyeshasgoy.jpg" />
    

    
    <meta name="title" content="JVM" />
    <meta property="og:title" content="JVM" />
    <meta property="twitter:title" content="JVM" />
    

    
    <meta name="description" content="这场残暴的欢愉,终将以残暴终结">
    <meta property="og:description" content="这场残暴的欢愉,终将以残暴终结" />
    <meta property="twitter:description" content="这场残暴的欢愉,终将以残暴终结" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="JAVA,PYTHON,GOLANG,VUE.js">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>JVM | 拾荒者博客</title>

    <link rel="canonical" href="/post/jvm/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    <script src="/js/lazysizes.min.js"></script>

    
    

</head>




<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Scavenger Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">All Posts</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/programming">programming</a>
                        </li>
                        
                        <li>
                            <a href="/categories/tech">tech</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/archive/">ARCHIVE</a></li>
                    
                        <li><a href="/notes/">NOTES</a></li>
                    
                        <li><a href="/about/">ABOUT</a></li>
                    
		            <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		           </li>
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/article-default.jpg')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/java" title="java">
                            java
                        </a>
                        
                        <a class="tag" href="/tags/jvm" title="jvm">
                            jvm
                        </a>
                        
                    </div>
                    <h1>JVM</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                Noper
                             
                            on 
                            Sunday, October 30, 2022
                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <h2 id="一jvm是一种规范">一、JVM是一种规范</h2>
<h3 id="jvm概述">JVM概述</h3>
<ul>
<li>JVM：Java Virtual Machine，也就是Java虚拟机</li>
<li>所谓虚拟机是指：通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的计算机系统</li>
<li>JVM是通过软件来模拟Java字节码的指令集，是Java程序的运行环境</li>
</ul>
<h3 id="jvm主要功能">JVM主要功能</h3>
<ul>
<li>通过 ClassLoader 寻找和装载 class 文件</li>
<li>解释字节码成为指令并执行，提供 class 文件的运行环境</li>
<li>进行运行期间的内存分配和垃圾回收</li>
<li>提供与硬件交互的平台</li>
</ul>
<h3 id="jvm规范作用">JVM规范作用</h3>
<ul>
<li>Java 虚拟机规范为不同的硬件提供了一种编译Java技术代码的规范</li>
<li>该规范使Java软件独立于平台，因为编译时针对作为虚拟机的“一般机器”而做</li>
<li>这个“一般机器”可用软件模拟并运行于各种现存的计算机系统，也可用硬件来实现</li>
</ul>
<p>
  <img src="/img/JVM/image-20210811172645279.png" alt="image-20210811172645279">

</p>
<h3 id="jvm规范定义的主要主要内容">JVM规范定义的主要主要内容</h3>
<ul>
<li>字节码指令集</li>
<li>Class文件的格式</li>
<li>数据类型和值</li>
<li>运行时数据区</li>
<li>栈帧</li>
<li>特殊方法</li>
<li>类库</li>
<li>异常</li>
<li>虚拟机的启动、加载、链接和初始化</li>
<li>…</li>
</ul>
<h3 id="jvm架构模型">JVM架构模型</h3>
<p>栈的指令架构</p>
<p>寄存器的指令架构</p>
<p>两种不同的指令集架构的区别</p>
<p>基于栈式架构的特点
设计和实现更简单，适用于资源受限的系统。
避开了寄存器的分配难题，使用零地址指令方式分配。
指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小（8个字节），编译器容易实现。
不需要硬件支持，可移植性好，更好实现跨平台。</p>
<p>基于寄存器架构的特点
典型的应用是x86的二进制指令集：比传统的PC以及Android的Dvlik虚拟机。
指令集架构完全依赖于硬件，可移植性差。
性能优秀和执行更高效。
花费更少的执行去完成一项操作。
在大布分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址(索引)指令为主，而基于栈式架构的指令集却是以零地址指令为主。</p>
<p>总结：
由于跨平台设计，Java指令都是根据栈来设计，不同平台CPU架构不同，所以不能设计为基于寄存器的。
基于栈设计的优点是跨平台，指令集小，编译容易实现，缺点是性能下降，实现相同的功能需要更多的指令。</p>
<h3 id="jvm的实现">JVM的实现</h3>
<p>HotSpot VM</p>
<h2 id="二jvm体系结构概览">二、JVM体系结构概览</h2>
<p>
  <img src="/img/JVM/image-20210811174514933.png" alt="image-20210811174514933">

</p>
<p>
  <img src="/img/JVM/image-20210817202826718.png" alt="image-20210817202826718">

</p>
<p>
  <img src="https://img-blog.csdnimg.cn/20210124162745758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUzNzY1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">

</p>
<p>首先要执行的代码是：</p>
<p>
  <img src="/img/JVM/image-20210818132349183.png" alt="image-20210818132349183">

</p>
<p>先执行main方法：</p>
<p>
  <img src="/img/JVM/image-20210818132416197.png" alt="image-20210818132416197">

</p>
<p>当要调用其他方法时：</p>
<p>
  <img src="/img/JVM/image-20210818132442379.png" alt="image-20210818132442379">

</p>
<pre><code>Student s = new Student(&quot;小明&quot;，18);
 
s 是指针，存放在栈中。
 
new Student(&quot;小明&quot;，18) 是对象 ，存放在堆中。
 
Student 类的信息存放在方法区。
 
总结 ：
 
对象的实例保存在堆上，对象的元数据（instantKlass）保存在方法区，对象的引用保存在栈上。
</code></pre><p>类加载是会先看方法区有没有已经加载过这个类，因此方法区中的类是唯一的。方法区中的类都是运行时的，都是正在使用的，是不能被GC的，所以可以理解成永久代。</p>
<p>
  <img src="https://img-blog.csdn.net/20180808112156511?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eXV5YW5nNjY4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img">

</p>
<h2 id="三java类加载机制">三、Java类加载机制</h2>
<h3 id="什么是类的加载">什么是类的加载</h3>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<p><strong>加载.class文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h3 id="类的生命周期">类的生命周期</h3>
<p>
  <img src="/img/JVM/image-20210812104533846.png" alt="image-20210812104533846">

</p>
<p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<p><strong>加载</strong></p>
<p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 <code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p><strong>连接</strong></p>
<p><strong>验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以 <code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 <code>java.lang.Object</code>之外。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备：为类的 <code>静态变量分</code>配内存，并将其初始化为默认值</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为： <code>publicstaticintvalue=3</code>；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 <code>publicstatic</code>指令是在程序编译后，存放于类构造器 <code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</blockquote>
<ul>
<li>3、如果类字段的字段属性表中存在 <code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li>
</ul>
<p>假设上面的类变量value被定义为： <code>publicstaticfinalintvalue=3</code>；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 <code>ConstantValue</code>的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中</p>
<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p><strong>初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>①声明类变量是指定初始值</li>
<li>②使用静态代码块为类变量指定初始值</li>
</ul>
<p>JVM初始化步骤</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 <code>Class.forName(“com.shengsiyuan.Test”)</code>）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ <code>JavaTest</code>），直接使用 <code>java.exe</code>命令来运行某个主类</li>
</ul>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了 <code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h3 id="类加载器">类加载器</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">JVMTest</span> <span style="color:#ff79c6">{</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">main</span><span style="color:#ff79c6">(</span>String<span style="color:#ff79c6">[]</span> args<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> JVMTest<span style="color:#ff79c6">().</span><span style="color:#50fa7b">getClass</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getClassLoader</span><span style="color:#ff79c6">());</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> JVMTest<span style="color:#ff79c6">().</span><span style="color:#50fa7b">getClass</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getClassLoader</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getParent</span><span style="color:#ff79c6">());</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">new</span> JVMTest<span style="color:#ff79c6">().</span><span style="color:#50fa7b">getClass</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getClassLoader</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getParent</span><span style="color:#ff79c6">().</span><span style="color:#50fa7b">getParent</span><span style="color:#ff79c6">());</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>输出结果</p>
<pre><code>sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@4554617c
null
</code></pre><p>从上面的结果可以看出，并没有获取到 <code>ExtClassLoader</code>的父Loader，原因是 <code>BootstrapLoader</code>（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p>
<h3 id="类加载器18">类加载器（1.8）</h3>
<p>
  <img src="/img/JVM/image-20210811174832468.png" alt="image-20210811174832468">

</p>
<blockquote>
<p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
</blockquote>
<h3 id="类加载器17">类加载器（1.7）</h3>
<p>
  <img src="/img/JVM/image-20210811175040260.png" alt="image-20210811175040260">

</p>
<h3 id="类加载器说明">类加载器说明</h3>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p><strong>启动类加载器</strong>： <code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。
<strong>扩展类加载器</strong>： <code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
<strong>应用程序类加载器</strong>： <code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<ul>
<li>1、在执行非置信代码之前，自动验证数字签名。</li>
<li>2、动态地创建符合用户特定需要的定制化构建类。</li>
<li>3、从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<p>启动类加载器：用于加载启动的基础模块类，比如：java.base、java.management、java.xml等
平台类加载器：用于加载一些平台相关的模块，比如：java.scripting、java.compiler *、java.corba *等
应用程序类加载器：用于加载应用级别的模块，比如：jak.compiler、jdk.jartool、jdk.jshell 等等；还加载 classpath 路径中的所有类库
JDK8：启动类加载器：负责将&lt;JAVA_HOME&gt;/lib，或者 -Xbootclasspath 参数指定的路径中的，且是虚拟机识别的类库加载到内存中（按照名字识别，比如 rt.jar，对于不能识别的文件不予装载）
JDK8：扩展类加载器：负责加载 &lt;JRE_HOME&gt;/lib/ext，或者 java.ext.dirs 系统变量所指定路径中的所有类库
JDK8：应用程序类加载器：负责加载 classpath 路径中的所有类库
Java 程序不能直接引用启动类加载器，直接设置 classLoader 为 null，默认就使用启动类加载器
类加载器并不需要等到某个类“首次主动使用”的时候才加载它，JVM规范允许类加载器在预料到某个类将要被使用的时候就预先加载它
如果在加载的时候 .class 文件缺失，会在该类首次主动使用时报告 LinkageError 错误，如果一直没有被使用，就不会报错</p>
<h3 id="jvm类加载机制">JVM类加载机制</h3>
<ul>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h3 id="类的加载方式">类的加载方式</h3>
<p><strong>JVM类加载机制</strong></p>
<ul>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<p>
  <img src="/img/JVM/image-20210812111421409.png" alt="image-20210812111421409">

</p>
<p>分别切换加载方式，会有不同的输出结果。</p>
<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h3 id="双亲委派机制">双亲委派机制</h3>
<p>当一个类收到类加载请求，它首先不会尝试自己去加载这个类，而是把这请求委派给父类去完成，每个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有摘到所需的Class），子类加载器才会尝试自己去加载。</p>
<p>采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类进行加载，这样九堡镇了使用不同类加载器最终得到的都是同一个Object对象。</p>
<p>双亲委派机制:</p>
<ul>
<li>1、当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>2、当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</li>
<li>3、如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li>
<li>4、若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li>
</ul>
<p>ClassLoader源码分析</p>
<p>
  <img src="/img/JVM/image-20210812111743995.png" alt="image-20210812111743995">

</p>
<h3 id="自定义类加载器">自定义类加载器</h3>
<h3 id="class文件">Class文件</h3>
<p>Class文件是JVM的输入，Java虚拟机规范中定义了Class文件的结构，Class文件是JVM实现平台无关、技术无关的基础
Class文件是一组以8字节为单位的字节流，各个数据项目按序紧凑排列
对于占用空间大于8字节的数据项，按照高位在前的方式分割成多个8字节进行存储
Class文件格式里面只有两种类型：无符号数、表
无符号数：基本数据类型，以u1、u2、u4、u8来代表几个字节的无符号数
表：由多个无符号和其他表构成的符合数据类型，通常以 &ldquo;_info&quot;结尾</p>
<h3 id="类加载子系统">类加载子系统</h3>
<p>(1)根据给定的全限定名类名(如java.lang.Object)来装载class文件的内容到Runtimedataarea中的methodarea(方法区域)。Java程序员可以extends java.lang.ClassLoader类来写自己的Classloader。(2) 对（1）中的加载过程是：当一个classloader启动时，classloader的生存地点在jvm中的堆，然后它去主机硬盘上去装载A.class到jvm的methodarea(方法区),方法区中的这个字节文件会被虚拟机拿来new A字节码，然后在堆内存生成了一个A字节码的对象，然后A自己码这个内存文件有两个引用，一个指向A的class对象，一个指向加载自己的classloader。见下图：

  <img src="/img/JVM/image-20210818124648317.png" alt="image-20210818124648317">

</p>
<h2 id="四java堆heap">四、Java堆（Heap)</h2>
<h3 id="1概述">1.概述</h3>
<p>对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。</p>
<p>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。</p>
<p>现在收集器基本采用分代回收算法，
所以Java堆还可以分为：新生代和老年代，再细致的份可以分为Eden空间、Form Survivor空间、To Survivor空间等。
从内存分配角度来看，线程共享的Java堆中可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p>
<p>方法区和堆对于进程来说是唯一的，进程对应一个JVM的实例，一个JVM中就有一个运行时数据区。一个JVM实例中只存在着一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候就被创建，其空间大小也就确定了。是JVM管理的最大的一块内存空间。堆内存大小是可以调节的。</p>
<p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他应该是被视为连续的。所有的对象实例以及数组都应该运行时分配在堆上（The heap is the run-time data area from which memory for all class instances and arrays is allocated）。</p>
<p>Java堆中可以可以划分线程私有的缓冲区（TLAB）。</p>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<h3 id="2设置堆的胆小和oom">2.设置堆的胆小和OOM</h3>
<p>&ldquo;-Xms&quot;用于表示堆区的起始内存，等价于-XX:InitialHeapSize
&ldquo;-Xmx&quot;用于表示堆区的最大内存，等价于-XX:MaxHeapSize
-X 是jvm运行参数
ms 是memory start的缩写</p>
<p>一旦堆区中的内存大小超过&rdquo;-Xmx&quot;所指定的最大内存时，将会抛出OutOfMemoryError异常。</p>
<p>若两个参数配置相同，则意味着为了能够在java垃圾回收机制清理完堆区后不需要重新分割计算堆的大小，从而提高性能。</p>
<p>默认情况下：初始内存大小为物理内存大小的64分之一，最大内存大小为物理电脑内存的4分之一。</p>
<p>查看堆设置的参数：方式一：jps / jstat -进程号
方式二：-XX:+PrintGCDetails（程序执行完后输出）</p>
<p>可以存放对象的区域只有伊甸园区（Eden）和幸存者1区（Survivor 0）或幸存者2区（Survivor 1）。</p>
<p>OOM（内存溢出、错误）
向一个ArrayList中不停的add一个对象。导致堆内存溢出。</p>
<h3 id="3年轻代和年老代">3.年轻代和年老代</h3>
<p>从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代又可以分为：Eden 空间、From Survivor空间、To Survivor空间。</p>
<p>存储在JVM的Java对象分为两类：</p>
<p>一类是生命周期比较短的瞬间，这类对象的创建和消亡都比较迅速
另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
Java堆区进一步细分的话，分为YoungGen和OldGen。</p>
<p>配置YoungGen和OldGen在堆结构的占比
默认 -XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3。</p>
<p>在HotSpot中，Eden空间和另外两个Survivor空间省所占比例是8:1:1。开发人员可以通过-XX:SurvivorRatio=8来调整这个空间比例。
-XX：-UseAdaptiveSizePlicy : 关闭自适应的内存分配策略。</p>
<p>几乎所有的Java对象都是在Eden区被new出来。</p>
<p>绝大部分的Java对象的销毁都是在新生代进行的。</p>
<p>可以使用&rdquo;-Xmn&quot;设置新生代最大内存大小，这个值一般默认就好了。</p>
<p>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：</p>
<pre><code>a.Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。

 b.代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。

 ② 养老区

     养老区用于保存从新生区筛选出来的 JAVA 对象，一般池对象都在这个区域活跃。

 ③ 永久区

     永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。

 如果出现java.lang.OutOfMemoryError: PermGen space，说明是Java虚拟机对永久代Perm内存设置不够。原因有二：

 a. 程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。

 b. 大量动态反射生成的类不断被加载，最终导致Perm区被占满。

 说明：

 Jdk1.6及之前：常量池分配在永久代 。

 Jdk1.7：有，但已经逐步“去永久代” 。

 Jdk1.8及之后：无(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)。
</code></pre>
<p>————————————————
版权声明：本文为CSDN博主「小爷欣欣」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/csdnliuxin123524/article/details/81303711</p>
<h3 id="4minor-gcmajor-gcfull-gc">4.Minor GC，Major GC，Full GC</h3>
<p>GC检索哪些是垃圾时，会导致用户线程暂停，所以希望GC出现的情况少，这里主要对Major GC、Full GC进行调优。因为它们两个GC的时间是Minor GC的10倍以上。</p>
<p>JVM在进行GC时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收，大部分时候回收的是新生代。</p>
<p>针对HotSpot VM的实现，他里面的GC按照回收区域分为两大类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。</p>
<p>部分收集
新生代（Eden、S0、S1）进行回收采用（Minor GC/ YGC）
老年代进行回收采用（Major GC/ OGC）
混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。
整堆收集
收集整个java堆和方法区的垃圾收集（Full GC）。
Minor GC的触发机制：</p>
<p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代指得是Eden代满，Survivor满不会触发GC。
Minor GC非常频繁，一般回收速度也比较快。
Minor GC会引发STW，暂停其他用户的线程，等垃圾回收线程结束，线程才恢复运行。
老年代GC（Major GC/Full GC）触发机制：</p>
<p>指发生在老年代的GC，对象从老年代消失。
出现了Major GC，经常会伴随至少一次的Minor GC。
如果Major GC后，内存还不足，就报OOM。
Full GC触发机制：</p>
<p>调用System.gc()时，系统建议执行Full GC，但是不必然执行。
老年代空间不足
方法区空间不足
通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</p>
<p>堆空间分代思想</p>
<p>为什么需要把Java堆分代，分代可以优化GC性能。</p>
<h3 id="5内存分配策略">5.内存分配策略</h3>
<p>如果对象在Eden出生并经过第一MinorGC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设置为1。对象在Survivor区每熬过一次MinorGC，年龄就增加1岁，当他的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p>
<p>对象晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshold来设置。</p>
<p>对象Promotion的规则
针对不同年龄段的对象分配规则如下：</p>
<p>优先分配到Eden
大对象直接分配到老年代
尽量避免程序中出现过多的大对象
长期存活的对象分配到老年代
动态对象的年龄判断
如果Survivor区中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
空间分配担保
-XX:HandlePromotionFailure
————————————————
版权声明：本文为CSDN博主「Wiki~」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/gsjwxhn/article/details/107048911</p>
<h3 id="6为对象分配内存">6.为对象分配内存</h3>
<p>堆区是线程的共享区域，任何线程都可以访问到堆区中的共享数据。
由于对象实例的创建在JVM中非常频繁，因此在并发的环境下从堆区中划分线程是不安全的。
为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。
TLAB是从内存分配的角度来说的，而不是垃圾回收的角度。它对Eden区域进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden区域。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题。同时还能够提升内存分配的吞吐量，因此我们可以将这个内存分配方式称为快速分配策略。</p>
<h3 id="7堆是分配对象的唯一选择吗">7.堆是分配对象的唯一选择吗</h3>
<p>随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的的变化，所有的对象都分配到堆上也逐渐变得不那么“绝对”了。</p>
<p>在特殊情况下，经过逃逸分析（Escape Analysis，这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无须在堆上分配内存，也无需进行垃圾回收，这也是最常见的堆外存储技术。</p>
<p>开发中能使用局部变量（可能存放在栈空间），就不要使用方法外定义。</p>
<p>代码优化
启动Server模式，因为在Server模式，才可以启动逃逸分析：-server。
开启逃逸分析：-XX:+DoEscapeAnalysis。
关闭逃逸分析：-XX:-DoEscapeAnalysis。
开启标量替换：-XX:+EliminateAllocaions（默认，允许将对象打散分配到栈上，比如对象拥有id和name两个字段，那么这两个字段会被视为两个独立的局部变量进行分配）。
关闭标量替换：-XX:-EliminateAllocaions。</p>
<p>栈上分配</p>
<p>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<p>场景：成员变量赋值、方法返回值、实例引用传递。</p>
<p>同步省略</p>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，==JIT编译器（字节码中还存在）==可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么JIT编译器在编译这个同步块的时候会取消这部分代码块的同步。这样就大大提高了并发的可能性，这个取消同步的过程就叫同步省略，也叫锁消除。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">f</span><span style="color:#ff79c6">(){</span>
        Object hollis <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Object<span style="color:#ff79c6">();</span>
        <span style="color:#8be9fd;font-style:italic">synchronized</span> <span style="color:#ff79c6">(</span>hollis<span style="color:#ff79c6">){</span>
            System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>hollis<span style="color:#ff79c6">);</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span>
    <span style="color:#6272a4">//代码中对hollis加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程访问到，所以在JIT编译阶段就会被优化掉。
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">f</span><span style="color:#ff79c6">(){</span>
        Object hollis <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Object<span style="color:#ff79c6">();</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>hollis<span style="color:#ff79c6">);</span>
    <span style="color:#ff79c6">}</span>

</code></pre></div><p>分离对象或标量替换</p>
<p>有的对象可能不需要作为一个连续的内存结构存储也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
**标量（Scalar）**是指无法再分解成更小数据的数据，Java中的原始类型就是标量。相对的，可以分解的数据叫做聚合量（Aggregate），Java中的聚合量，因为他可以分解成其他聚合量和标量。
在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含若干个成员变量来替换，这个过程就是标量替换。</p>
<h2 id="五方法区method-area">五、方法区（Method Area）</h2>
<p>属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<blockquote>
<p>运行时常量池</p>
<p>属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。</p>
</blockquote>
<p>《Java虚拟机规范》中说明：“尽管所有的方法区在逻辑上属于堆的一部分，但是一些简单的实现可能不会选择去进行垃圾收集或进行压缩。”</p>
<h3 id="1设置方法区大小与oom">1.设置方法区大小与OOM</h3>
<p>jar过多，大量动态生成反射类。关闭JVM时会释放方法区。
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在不在虚拟机设置的内存中，而使用本地内存。
《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。
方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。
jdk8之后元数据区大小可以使用参数-XX:MetaspaceSize=100m和-XX:MaxMetaspaceSize=100m指定。
默认值依赖于平台。
与永久代不同的是，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出OutOfMemoryError: Metaspace异常。
要解决OOM异常或者heap space的异常，一般手段是首先通过内存映像分析工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要先分清楚出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了对象泄漏信息，以及GC Roots引用链信息，就可以比较准确的定位出泄漏的代码位置。</p>
<p>如果不存在内存泄漏，换句话说就是内存中的对象确实都还活着，那就应当检查虚拟机的堆参数（-Xmx、-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。</p>
<h3 id="2方法区的内部结构">2.方法区的内部结构</h3>
<p>Method Area存储内容如下：被虚拟机加载的方法信息、类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>类型信息：
对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息。</p>
<p>这个类型完整的完整有效名称（全名=包名.类名）
这个类型直接父类的完整有效名（对于interface或者是java.lang.Object，都没有父类）
这个类型的修饰符（public、abstract、final的某个子集）
这个类型直接接口和一个有序列表。
域（Field）信息：
成员变量（属性）</p>
<p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient的某个子集）
方法（Method）信息</p>
<p>方法名称
方法的返回类型（void）
方法参数的数量和类型（按顺序）
方法的修饰符（public、private、protected、static、final、synchronized、native、abstract的某个子集）
方法的字节码（bytecode）、操作数栈、局部变量表及大小（abstract和native方法除外）
异常表（abstract和native方法除外）
每个异常的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。
方法区内部包含了运行时常量池。
字节码文件，内部包含了常量池。
要想弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。
要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</p>
<p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含了一项信息那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<p>non-final的类变量
静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分，类变量被类所有的实例共享，即时没有类实例你也可以访问他。</p>
<p>全局常量：final+static
重要：</p>
<p>被声明为final的类变量的处理方法不同，每个全局变量在编译的时候就会被分配了。（编译为字节码.class的时候就赋值）。</p>
<p>如果只被static修饰，会在类加载器加载的准备阶段默认赋值为0（验证 - 准备 - 解析），然后在Initialization阶段对他进行准确赋值。</p>
<p>对于静态代码块的赋值有个。
构造方法的赋值</p>
<p>运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>字节码文件，内部包含了常量池（Constant Pool）。</p>
<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>JVM为每个已加载的类型（类或接口）都维护一个常量池，池中的数据项数组项一样，是通过索引访问的，</p>
<p>运行时常量池中包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行时也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>运行时常量池类似于传统编程语言的符号表（symbol table），但是它所包含的数据却比符号表要丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，JVM会抛出OutOfMemoryError异常。</p>
<p>为什么需要常量池
一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是Constant Pool Table，包括各种字面量和对类型、域和方法的符号引用。</p>
<p>一个Java源文件中的类、 接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能存放到字节码里，换量一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</p>
<h3 id="3方法区演进">3.方法区演进</h3>
<ol>
<li>
<p>首先明确：只有HotSpot才有永久代。</p>
</li>
<li>
<p>HotSpot中的方法区的变化：</p>
<p>jdk版本	方法区如何实现
jdk1.6及以前	有永久代（permanent generation），静态变量存放在永久代上
jdk1.7	有永久代，但已逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中
jdk1.8及以后	无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</p>
</li>
</ol>
<p>永久代为什么要被元空间替换？</p>
<p>This is part of JRockit and HotSpot convergence effort. JRockit customers do not need to configure the permanent generation(since JRockit does not have a permanent generation) and are accustomed to not configuring the permanent generation.</p>
<p>随着Java8的到来，Hotspot VM中再也见不到永久代了，但是这不意味着类的元数据信息也消失了，这些数据被移到一个与堆不相连的本地内存区域，这个区域叫做元空间。</p>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
<p>元空间与永久代最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p>
<p>一、为永久代设置空间大小是很难确定的。
二、对永久代进行调优很困难。
StringTable为什么要调整？</p>
<p>jdk7中将StringTable放到了堆空间。因为永久代的回收效率很低，在Full GC才会触发，而Full GC是老年代空间不足、永久代不足时才会触发。这就导致StringTable回收率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h3 id="4方法区垃圾回收">4.方法区垃圾回收</h3>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完成实现方法区类型卸载的收集器存在。这部分区域的回收有时又是必要的。</p>
<p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>方法区内常量池中存放的两大类常量：字面量和符号引用，字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<p>类和接口的全限定名
字段的名称和描述符
方法的名称和描述符
HotSpot虚拟机对常量池的回收策略很明确：只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>回收废弃常量与回收Java堆中的对象非常类似。</p>
<p>然而对于判定一个类型是否属于“不再被使用的类”的条件就非常苛刻了，需要满足以下三个条件：</p>
<p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
加载该类的加载器已经被回收，这个条件除非时经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载，否则通常是很难达成的。
该类对应的Java.lang.Class对象么有在任何地方被引用，无法在任何地方通过发射访问该类方法。
满足上面三个条件，仅仅是“被允许”回收，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot提供了-XX:TraceClassUnLoading查看类加载和卸载信息。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="六java栈stack">六、Java栈（Stack）</h2>
<h3 id="1概述-1">1.概述</h3>
<p>由于跨平台性的设计，Java指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。
优点：跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p>
<p>栈是运行时单位，堆是存储时单位
栈解决程序的运行问题，即程序如何执行，或者如何处理数据。
堆解决的数据存储的问题，即数据怎么放，放在哪。</p>
<p>Java虚拟机栈，早期也叫Java栈。线程私有，生命周期和线程一致。每个线程在创建时都会创建一个虚拟机栈，描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。</p>
<blockquote>
<p>局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和 returnAddress 类型(指向了一条字节码指令的地址)</p>
</blockquote>
<p>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虛拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈深度超过Java虚拟机栈允许的最大深度，Java虛拟机将会抛出一个StackOverflowError异常。（自己调自己）</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。</p>
<blockquote>
<p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。
OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存</p>
</blockquote>
<h3 id="2栈的存储单位">2.栈的存储单位</h3>
<ul>
<li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在的。</li>
<li>在这个线程上正在执行的每个方法各自对应一个栈帧。</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li>
</ul>
<p>
  <img src="/img/JVM/image-20210818123418049.png" alt="image-20210818123418049">

</p>
<p>2.1栈运行原理</p>
<p>不同线程中包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会返回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为Current Frame，与当前栈帧相对应的方法就是Current Method，定义这个方法的就是Current Class。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>Java中有两种返回函数的方式，</p>
<p>一种是正常的函数返回，使用return指令
另一种是抛出异常，不管使用哪种方式，都会导致栈帧被弹出。</p>
<p>2.2 栈帧的内部结构</p>
<ul>
<li>局部变量表（Local Variables）</li>
<li>操作数栈（Operand Stack）或表达式栈</li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p>2.3 局部变量表</p>
<p>由于局部变量是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p>
<p>局部变量表所需的容量大小是编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间不会改变局部变量的大小的。</p>
<p>方法嵌套调用次数由栈的大小决定，一般来说，栈越大，方法嵌套调用次数越多。对于一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，他的栈帧就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>==局部变量表中的变量值只能在当前方法调用中有效。==在方法执行时，虚拟机通过使用局部变量完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈的销毁，局部变量也会随之销毁。</p>
<p>Start PC（声明的下一行） + Length（有效长度） = 当前作用域的范围。</p>
<p>2.4 Slot</p>
<p>参数值存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
<p>局部变量表最基本的存储单元是slot（变量槽），32位的基本数据类型、引用类型占一个槽，64位（long、double）的基本类型占用两个槽。</p>
<p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引可以成功访问到局部变量表中指定的局部变量值。</p>
<p>当一个实例方法被调用的时候，他的方法参数和==方法体内部定义的局部变量将会按照顺序被复制到局部变量表的Slot上。</p>
<p>如果需要访问的局部变量表中64bit的局部变量值时，那么只需要第一个索引即可。</p>
<p>如果当前栈帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的Slot处，其余参数按照顺序进行排列。
这进而解释了为什么静态方法为什么不能使用this，因为this不存在于静态方法的局部变量表中。构造器和实例方法都可以使用this。</p>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量超出了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期过期的局部变量的槽位，从而达到资源利用的目的</p>
<p>2.5 静态变量和局部变量的对比</p>
<p>参数表分配完毕后，再根据方法体内定义的变量的顺序和作用域分配。
类变量表有两次初始化的机会，一次是在准备阶段、另一次是在初始化阶段
和类变量不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为初始化，否则无法使用。</p>
<p>变量的分类
根据数据类型来分
基本数据类型
引用数据类型
根据在类中声明位置来分
成员变量
在使用前都经历过默认初始化赋值，都具有默认值。
类变量、成员变量（静态修饰）：linking的prepare阶段，默认赋值，initial阶段给类变量进行显式赋值，即静态代码块赋值。
实例变量（无静态修饰）：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值。
局部变量
在使用前必须进行显式赋值，否则编译不通过。</p>
<p>2.6 优化</p>
<p>在栈帧中，与性能调优最关系最密切的部分就是局部变量表，在执行方法时，虚拟机使用局部变量表完成方法的传递。
局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h3 id="3操作数栈top-of-stack-cashing">3.操作数栈（Top-of-Stack Cashing）</h3>
<p>栈可以使用数组或者链表来实现，这里使用数组来实现。这样的话，在使用前数组的长度是固定不可变的，也就是在编译器已经确定了，局部变量表也是编译时确定。</p>
<p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，或者是表达式栈（Expression Stack）。</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈出栈。</p>
<p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈
比如复制、交换、求和等操作。
JAVA虚拟机的解释引擎是基于栈的执行引擎，其中栈指的是操作数栈。</p>
<p>操作数栈，主要用于保存计算过程中的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之创建出来，这个方法的操作数栈是空的。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了。保存在方法的Code属性中，为max_stack值。</p>
<p>操作数栈并非采用访问索引的方式进行数组访问，而只能通过push和pop操作来完成一次数据访问。</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令，操作数栈中的元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证。同时在类加载过程中的类检验阶段的数据流分析阶段再次验证。</p>
<h3 id="4栈顶缓存技术top-of-stack-cashing">4.栈顶缓存技术（Top-of-Stack Cashing）</h3>
<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，同时也就意味着需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁的执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM设计者提出了栈顶缓存（ToS）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h3 id="5动态链接dynamic-linking">5.动态链接（Dynamic Linking）</h3>
<p>帧数据区（方法返回地址、动态链接、一些附加信息）。</p>
<p>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令。</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用（Symbolic Reference）**保存在class文件的常量池里。
比如：描述一个方法调用另外其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是将这些符号引用作为调用方法的直接引用。</p>
<p>直白点说：动态链接就是帧中指向方法区中的运行时常量池的方法引用。</p>
<p>作用：常量池的作用就是为了提供一些符号和常量，便于指令的识别。</p>
<h3 id="6方法的调用解析和分派">6.方法的调用：解析和分派</h3>
<p>在JVM中，将符号引用（#?）转换为调用方法的直接引用与方法的绑定机制相关。
绑定是一个字段、方法或者类在符号引用被替换为直接引用过程，这仅仅发生一次。</p>
<p>静态链接：当一个字节码文件装载进JVM内部时，如果被调用的方法在编译期可知，且运行起保持不变时，这种情况下将调用符号转化为直接引用的过程称之为静态链接。对应的绑定机制称为早期绑定。（非虚方法 ）
动态链接：如果被调用的方法在编译器期间无法确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转化为直接引用，由于这种引用转化过程具备动态性，因此称之为动态链接。对应的绑定机制成为晚期绑定。(虚方法)
编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种方式。</p>
<p>6.1 虚方法和非虚方法</p>
<ul>
<li>非虚方法
<ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本运行时是不可变的。这样的方法就是非虚方法。</li>
<li>静态方法，私有方法，final方法，实例构造器、父类方法都是非虚方法（super）。</li>
</ul>
</li>
<li>虚方法
<ul>
<li>其他方法被称为虚方法。不确定</li>
</ul>
</li>
</ul>
<p>子类对象的多态性的前提：类的继承关系， 方法的重写</p>
<p>虚拟机提供了以下几条方法的调用指令</p>
<p>普通调用指令
invokestatic：调用静态方法，解析阶段确定唯一方法版本
invokespecial：调用init方法、私有及父类方法，解析阶段确定唯一方法版本
invokevirtual：调用所有虚方法
invokeinterface：调用接口方法
动态调用指令
invokedynamic：动态解析出需要调用的方法，然后执行。
前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用方法称为非虚方法，其余的final修饰除外称为虚方法。</p>
<p>6.2 关于invokedynamic指令</p>
<p>JVM字节码指令一直比较稳定，一直到Java7中才增加了一个invokeddynamic指令，这是Java为了实现[动态类型语言]支持而做的一种改进步。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令，直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接生成的方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是Java平台的动态语言编译器。</p>
<p>动态类型语言和静态类型语言
动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之就是动态类型语言。</p>
<p>java是静态类型语言。</p>
<p>再直白一点说就是，静态类型语言是判断变量自身的类型信息，动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特性。</p>
<p>6.3 方法重写本质</p>
<p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做C。
如果类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.rllegalAccessError异常。
否则，按照继承关系从下往上依次对C的各个父类进行第 2 步的搜索和验证过程。
如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。
java.lang.rllegalAccessError属于程序试图访问或修改一个属性或调用一个方法，这个属性或方法你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<p>6.4 虚方法表</p>
<p>在面向对象的编程中，会很频繁的使用到动态分配，如果在每次动态分配的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。</p>
<p>因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（Virtual method table）来实现。使用索引来替代查找。</p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</p>
<p>虚方法什么时候创建
虚方法表会在类加载==链接阶段（解析）==被创建并初始化，类的变量初始化值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
<h3 id="7方法返回地址return-address">7.方法返回地址（return address）</h3>
<p>存放调用该方法的PC寄存器的值</p>
<p>一个方法的结束有两种方式：</p>
<p>正常执行完成
执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者。
一个方法的在正常调用完成后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
在字节码指令中，返回指令包含ireturn（boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn（引用类型），另外还有return指令提供声明的void方法、实例初始化方法、类和接口的初始化方法使用。
出现未处理异常，非正常退出
在方法执行的过程中遇到异常，并且异常在方法内没有得到处理，也就是只要本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称异常完成出口
方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。
无论哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>本质上，方法的退出就是当前栈帧的出栈过程。此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于：通过异常完成的出口退出的不会给他上层调用者产生任何的返回值。</p>
<h2 id="七本地方法栈native-method-stack">七、本地方法栈（Native Method Stack）</h2>
<p>区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。</p>
<p>简单的讲，一个Native Method 就是一个Java调用非Java的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，</p>
<p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于本地方法的调用。
本地方法栈也是线程私有。</p>
<p>允许被实现成固定或者是可动态扩展的大小（在内存溢出方面是相同的）</p>
<p>当某个线程调用一个本地方法时，他就进入一个全新的并且不再受虚拟机限制的世界。他和虚拟机拥有相同的权限。</p>
<p>本地方法可以通过本地本地方法接口来访问虚拟机内部的运行时数据区
它甚至可以直接使用本地处理器中的寄存器
直接从本地内存的堆中分配任意数量的内存
HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。</p>
<p>（1）本地方法就是带有native标识符修饰的方法；（2）native修饰符修饰的方法并不提供方法体，但因为其实现体是由非java代码在在外部实现的，因此不能与abstract连用；（3）存在的意义：不方便用java语言写的代码，使用更为专业的语言写更合适；甚至有些JVM的实现就是用c编写的，所以只能使用c来写，</p>
<p>（4）更多的本地方法最好是与jdk的执行引擎的解释器语言一致（执行引擎、解释器：参考21的执行引擎）；</p>
<p>（5）Windows、Linux、UNIX、Dos操作系统的核心代码大部分是使用C和C＋＋编写，底层接口用汇编编写．</p>
<p>（6）为什么native方法修饰的修饰的方法PC程序计数器为undefined。读懂上面的所有知识点可以就很容易自己理解了。在一开始类加载时，native修饰的方法就被保存在了本地方法栈中，当需要调用native方法时，调用的是一个指向本地方法栈中某方法的地址，然后执行方法直接与操作系统交互，返回运行结果。整个过程并没有经过执行引擎的解释器把字节码解释成操作系统语言，PC计数器也就没有起作用。
————————————————
版权声明：本文为CSDN博主「小爷欣欣」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/csdnliuxin123524/article/details/81303711</p>
<h2 id="八程序计数器program-counter-register">八、程序计数器（Program Counter Register）</h2>
<p>Register 的命名源于CPU寄存器，寄存器存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行。这里并非广义上所指的物理寄存器，或许将它译为PC计数器更加贴切。JVM的PC寄存器是对物理寄存器的一种抽象模拟。</p>
<p>作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p>任何一个线程都只有一个方法在执行，也就是所谓的当前方法，程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是执行native方法，则是未指定值（undefined）。</p>
<p>他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>一、使用PC寄存器存储字节码指令地址有什么用？为什么使用PC寄存器记录当前线程的执行地址呢？
因为CPU需要不停的切换各个线程（每个线程独享一份寄存器），这时候切换回来以后，就得知道接着从哪开始继续执行。
JVM的字节码解释器需要通改变寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p>二、PC寄存器为什么会被设定为线程私有？
多线程在一个特定的时间段内只会执行其中某一线程的方法，CPU会不停的做任务切换，这样必然导致经常的中断和恢复，为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现干扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某一个线程中的一条指令。这样必然导致经常中断和恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vcm95aTEyMy81NDgwOTYvb182MDk5NTYyNzQ1MzMwMDczNzguZ2lm" alt="img">

</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Demo</span> <span style="color:#ff79c6">{</span>
 
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">foo</span><span style="color:#ff79c6">()</span> <span style="color:#ff79c6">{</span>
 
       <span style="color:#8be9fd">int</span> a <span style="color:#ff79c6">=</span> 1<span style="color:#ff79c6">;</span>
 
       <span style="color:#8be9fd">int</span> b <span style="color:#ff79c6">=</span> 2<span style="color:#ff79c6">;</span>
 
       <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">(</span>a <span style="color:#ff79c6">+</span> b<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">*</span> 5<span style="color:#ff79c6">;</span>
 
    <span style="color:#ff79c6">}</span>
 
<span style="color:#ff79c6">}</span>
</code></pre></div><p>下面简单解释下执行过程，注意：偏移量的数字只是简单代表第几个指令哦，首先常数1入栈，栈顶元素就是1，然后栈顶元素移入局部变量区存储，常数2入栈，栈顶元素变为2，然后栈顶元素移入局部变量区存储；接着1，2依次再次入栈，弹出栈顶两个元素相加后结果入栈，将5入栈，栈顶两个元素弹出并相乘后结果入栈，然后栈顶变为15，最后移入局部变量。执行return命令如果当前线程对应的栈中没有了栈帧，这个Java栈也将会被JVM撤销。</p>
<h2 id="九执行引擎">九、执行引擎</h2>
<h3 id="执行引擎概述">执行引擎概述</h3>
<p>执行引擎是Java虚拟机核心组成部分之一。</p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两个机器都有代码执行能力，其区别于物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的（高效），而虚拟机的执行指令则是由执行引擎自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
<p>JVM的主要任务是负责装载字节码到其内部，但字节码并不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p>那么，如果想要一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<p>Java代码编译和执行过程
执行引擎在执行过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。
当方法在执行的过程中，执行引擎可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。
从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p>
<h3 id="解释器模版解释器">解释器（模版解释器）</h3>
<p>解释器：当Java虚拟机启动的时候会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行。</p>
<p>模版解释器将每一条字节码和一个模版函数相关联，模版函数中直接产生这条字节码执行时的机器码，从很大程度上提高了解释器的性能。</p>
<p>在HotSpot VM中，解释器主要由Interpreter模块个Code模块构成</p>
<p>Interpreter模块：实现了解释器的核心功能。
Code模块：用于管理HotSpot VM运行时生成的本地机器指令。
当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待及时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，及时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<p>JIT编译器
Just In Time Compiler：就是虚拟机将源代码直接编译成和本地平台相关的机器语言。</p>
<p>Java语言的“编译器”其实是一段“不确定”的操作过程，</p>
<p>因为它可能是指一个前端编译器（其实叫“编译器的前端”更确切一些）把.java文件转变为.class文件的过程。</p>
<p>Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）
可能是指虚拟机的后端运行期编译器（Just In Time Compiler），把字节码转变成机器码的过程（中间有个汇编）。</p>
<p>HotSpot VM的C1、C2编译器
还可能是指使用静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把.java文件编译成机器代码的过程。</p>
<p>GUN Compiler for the Java（GCJ）、Excelsior JET
热点代码探测方式
当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用的执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”作出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On Stack Replacement)编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要个明确的國值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</p>
<p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器(Invocation Counter) 和 回边计数器(BackEdge Counter)。
➢方法调用计数器用于统计方法的调用次数
这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是 1500 次，在Server模式下是10000次。超过这个阈值， 就会触发JIT编译。
这个阈值可以通过虚拟机参数:xx: CompileThreshold来人为设定。
当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交-一个该方法的代码编译请求。</p>
<p>➢回边计数器则用于统计循环体执行的循环次数
他的作用是统计一个方法中循坏体代码执行的次数，在字节码中遇到控制流向后跳转的指令为“回边（Back Edge）”显然，建立回边计数器统计目的就是为了触发OSR编译。</p>
<p>热度衰减
如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行效率，即一段时间之内方法被调用的次数。当超过一定的时间段，如果方法的调用次数仍然不足以让它提交给及时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法掉用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期**（Counter Half Life Time）**。</p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:UseCounterDeacy来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分都会被编译成本地代码。</p>
<p>另外可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<p>AOT编译器
Ahead Of Time Compiler 在程序运行之前，便将字节码转换为机器码的过程。

  <img src="/img/JVM/image-20210818124944652.png" alt="image-20210818124944652">

</p>
<p>解释器：一条一条地读取，解释并且执行字节码指令。因为它一条一条地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢。这是解释执行的语言的一个缺点。字节码这种“语言”基本来说是解释执行的。
即时(Just-In-Time)编译器：即时编译器被引入用来弥补解释器的缺点。执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行它。执行本地代码比一条一条进行解释执行的速度快很多。编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。
————————————————
版权声明：本文为CSDN博主「小爷欣欣」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/csdnliuxin123524/article/details/81303711</p>
<h2 id="九jvm调优">九、JVM调优</h2>
<p>
  <img src="/img/JVM/image-20210812112303430.png" alt="image-20210812112303430">

</p>
<p>控制参数</p>
<ul>
<li>-Xms设置堆的最小空间大小。</li>
<li>-Xmx设置堆的最大空间大小。</li>
<li>-XX:NewSize设置新生代最小空间大小。</li>
<li>-XX:MaxNewSize设置新生代最大空间大小。</li>
<li>-XX:PermSize设置永久代最小空间大小。</li>
<li>-XX:MaxPermSize设置永久代最大空间大小。</li>
<li>-Xss设置每个线程的堆栈大小。</li>
</ul>
<h2 id="十hotspot虚拟机">十、HotSpot虚拟机</h2>
<p><a href="https://blog.csdn.net/qq_41701956/article/details/81664921">https://blog.csdn.net/qq_41701956/article/details/81664921</a></p>
<p>1、对象的创建</p>
<p>遇到 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，执行相应的类加载。</p>
<p>类加载检查通过之后，为新对象分配内存(内存大小在类加载完成后便可确认)。在堆的空闲内存中划分一块区域(‘指针碰撞-内存规整’或‘空闲列表-内存交错’的分配方式)。</p>
<p>前面讲的每个线程在堆中都会有私有的分配缓冲区(TLAB)，这样可以很大程度避免在并发情况下频繁创建对象造成的线程不安全。</p>
<p>内存空间分配完成后会初始化为 0(不包括对象头)，接下来就是填充对象头，把对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息存入对象头。</p>
<p>执行 new 指令后执行 init 方法后才算一份真正可用的对象创建完成。</p>
<p>2、对象的内存布局</p>
<blockquote>
<p>在 HotSpot 虚拟机中，分为 3 块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p>
</blockquote>
<p>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p>
<p>实例数据(Instance Data)：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p>
<p>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p>
<p>3、对象的访问定位</p>
<blockquote>
<p>使用对象时，通过栈上的 reference 数据来操作堆上的具体对象。</p>
</blockquote>
<p>通过句柄访问</p>
<p>Java 堆中会分配一块内存作为句柄池。reference 存储的是句柄地址。详情见图。</p>
<p>
  <img src="/img/JVM/image-20210817204911163.png" alt="image-20210817204911163">

</p>
<p>使用直接指针访问</p>
<p>reference 中直接存储对象地址</p>
<p>
  <img src="/img/JVM/image-20210817205020452.png" alt="image-20210817205020452">

</p>
<p>比较：使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p>
<h2 id="十一垃圾回收机制">十一、垃圾回收机制</h2>
<p>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是这部分内存。</p>
<p>怎样判断对象已”死“</p>
<p>引用计数法</p>
<p>给对象添加一个引用计数器。但是难以解决循环引用问题</p>
<p>
  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNGMyODlhMjI0Y2I0OTQ0ZTQ5OWZiNWJmZDMzZTU5MmY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img">

</p>
<p>从图中可以看出，如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。</p>
<p>可达性分析法</p>
<p>通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。</p>
<p>
  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img">

</p>
<p>可作为 GC Roots 的对象：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象</li>
</ul>
<p>关于引用</p>
<p>JDK 1.2 之后，引用概念进行了扩充</p>
<p>下面四种引用强度一次逐渐减弱</p>
<p>强引用</p>
<p>类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。</p>
<p>软引用</p>
<p>SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。</p>
<p>弱引用</p>
<p>WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。</p>
<p>虚引用</p>
<p>PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<p>对象生存还是死亡</p>
<p>即使在可达性分析算法中不可达的对象，也并非是“facebook”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可。</p>
<p>finalize() 方法只会被系统自动调用一次。</p>
<p>回收方法区</p>
<blockquote>
<p>在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代垃圾回收主要两部分内容：废弃的常量和无用的类。</p>
</blockquote>
<p>判断废弃常量：一般是判断没有该常量的引用。</p>
<p>判断无用的类：要以下三个条件都满足</p>
<p>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例
加载该类的 ClassLoader 已经被回收
该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</p>
<p>复制算法</p>
<p>标记-清除算法</p>
<p>标记-整理算法</p>
<p>分代收集算法</p>
<h2 id="十二垃圾回收器">十二、垃圾回收器</h2>
<p>收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。</p>
<p>
  <img src="/img/JVM/image-20210817211707214.png" alt="image-20210817211707214">

</p>
<p>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p>
<p>Serial 收集器</p>
<p>这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p>
<p>
  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img">

</p>
<p>
  <img src="/img/JVM/image-20210818113805259.png" alt="image-20210818113805259">

</p>
<h2 id="十三stringtable">十三、StringTable</h2>
<h3 id="1string的基本特性">1.String的基本特性</h3>
<p>String 声明为final，不可被继承。</p>
<p>String实现了Serializable接口：表示字符串是支持序列化的，实现了Comparable接口：表示String可以比较大小。</p>
<p>String在JDK8及以前内部定义了final char[] value 用于存储字符串数据。JDK9时改为byte[]。这样节约了一些空间。</p>
<p>String：代表不可变的字符序列。简称：不可变性。</p>
<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p>
<p>当对现有的字符串进行链接操作（“+”）时，也需要重新指定内存区域赋值，不能使用原有的value赋值。</p>
<p>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
<p>字符串常量池不会存储相同内容的字符串</p>
<p>String的String Pool是一个固定大小的HashTable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成影响就是当调用String.intern时性能会大幅度下降。</p>
<p>使用-XX:StringTableSize可设置StringTable的长度（固定不变）。</p>
<p>在JDK6中的StringTable是固定的，就是1009长度，所以如果常量池中的字符串过多会导致效率下降很快。StringSize设置没有要求。</p>
<p>在JDK7中，StringTable的长度默认值是60013，StringSize设置没有要求。</p>
<p>JDK8中，1009是可设置的最小值。</p>
<h3 id="2string的内存分配">2.String的内存分配</h3>
<p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就是类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。他的主要使用方法有两种：</p>
<p>直接使用双引号声明出来的对象会直接存储在常量池中。
如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</p>
<h3 id="3字符串拼接操作">3.字符串拼接操作</h3>
<p>常量与常量的拼接结果在常量池，原理是编译期优化
常量池不会存在相同内容的常量
只要其中有一个是变量，结果就在堆中。变量拼接原理是StringBuilder的append。（final修饰是常量）
如果拼接的结果是调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址
intern()：判断字符串常量池中是否存在某个常量值，如果存在则返回常量池中这个值的地址，如果字符串常量池中没有这个常量，则在常量池加载一份，并返回此对象的地址。</p>
<p>StringBuilder的append()的方式添加字符串的效率远远高于使用String的字符串拼接方式。
好处：</p>
<p>StringBuilder的append()方式，自始至终只创建一个StringBuilder的对象。
而使用字符串拼接的方式创建多个StringBuilder和String对象。
使用String字符串拼接的方式：内存中由于创建了较多的StringBuilder和Sting对象，内存占用更大。如果进行GC，需要花费更多的时间。
改进的空间：
在实际开发中，如果基本确定要前前后后添加字符串长度不高于某个限定值highLevel的情况下，建议使用构造器：</p>
<pre><code>    StringBuilder str = new StringBuilder(highLevel);

</code></pre><h3 id="4intern使用">4.intern()使用</h3>
<p>Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作的执行速度，这个值会被存放在字符串内部池（String Intern Pool）。</p>
<p>JDK1.6中，将这个字符串对象放入常量池中</p>
<p>如果常量池有，则并不会放入，返回已有的常量池的对象的地址
如果没有，会把此对象复制一份，放入常量池，并返回常量池对象地址（产生新对象）。
JDK1.7中，将这个字符串对象放入常量池</p>
<p>如果常量池中有，则不会放入，返回已有的常量池中的对象的地址
如果没有，则会把对象的引用地址复制一份，放入常量池，并返回常量池的引用地址（地址相同）。</p>


                

                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/postgresql%E4%BD%BF%E7%94%A8/" data-toggle="tooltip" data-placement="top" title="Postgresql使用">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-toggle="tooltip" data-placement="top" title="Java并发编程">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

                



            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        <a href="/tags/java" title="java">
                            java
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:yuandaiqi@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/echocogito">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://stackoverflow.com/users/yourstackoverflowid">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-stack-overflow fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
            
            
            
           
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Scavenger Blog 2022
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>









<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body>
</html>
